<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>quop_mpi &mdash; QuOp_MPI 1.3.0 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/documentation_options.js?v=1f29e9d3"></script>
        <script src="_static/doctools.js?v=9a2dae69"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="QuOp Functions" href="quop_functions.html" />
    <link rel="prev" title="Examples" href="examples.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            QuOp_MPI
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="readme_link.html">QuOp_MPI</a></li>
<li class="toctree-l1"><a class="reference internal" href="readme_link.html#installation">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="readme_link.html#documentation">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="readme_link.html#building-fftw3-and-hdf5-from-source">Building FFTW3 and HDF5 From Source</a></li>
<li class="toctree-l1"><a class="reference internal" href="readme_link.html#environment-setup">Environment Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="readme_link.html#license">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="readme_link.html#contact-information">Contact Information</a></li>
<li class="toctree-l1"><a class="reference internal" href="theoretical_background.html">Theoretical Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="package_overview.html">Package Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">quop_mpi</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#quop_mpi.Ansatz"><code class="docutils literal notranslate"><span class="pre">Ansatz</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.Ansatz.benchmark"><code class="docutils literal notranslate"><span class="pre">Ansatz.benchmark()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.Ansatz.evaluate"><code class="docutils literal notranslate"><span class="pre">Ansatz.evaluate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.Ansatz.evolve_state"><code class="docutils literal notranslate"><span class="pre">Ansatz.evolve_state()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.Ansatz.execute"><code class="docutils literal notranslate"><span class="pre">Ansatz.execute()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.Ansatz.gen_initial_params"><code class="docutils literal notranslate"><span class="pre">Ansatz.gen_initial_params()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.Ansatz.get_expectation_value"><code class="docutils literal notranslate"><span class="pre">Ansatz.get_expectation_value()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.Ansatz.get_final_state"><code class="docutils literal notranslate"><span class="pre">Ansatz.get_final_state()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.Ansatz.get_probabilities"><code class="docutils literal notranslate"><span class="pre">Ansatz.get_probabilities()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.Ansatz.objective"><code class="docutils literal notranslate"><span class="pre">Ansatz.objective()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.Ansatz.print_optimiser_result"><code class="docutils literal notranslate"><span class="pre">Ansatz.print_optimiser_result()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.Ansatz.print_result"><code class="docutils literal notranslate"><span class="pre">Ansatz.print_result()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.Ansatz.save"><code class="docutils literal notranslate"><span class="pre">Ansatz.save()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.Ansatz.set_depth"><code class="docutils literal notranslate"><span class="pre">Ansatz.set_depth()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.Ansatz.set_initial_state"><code class="docutils literal notranslate"><span class="pre">Ansatz.set_initial_state()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.Ansatz.set_log"><code class="docutils literal notranslate"><span class="pre">Ansatz.set_log()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.Ansatz.set_objective"><code class="docutils literal notranslate"><span class="pre">Ansatz.set_objective()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.Ansatz.set_observables"><code class="docutils literal notranslate"><span class="pre">Ansatz.set_observables()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.Ansatz.set_optimiser"><code class="docutils literal notranslate"><span class="pre">Ansatz.set_optimiser()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.Ansatz.set_parallel_jacobian"><code class="docutils literal notranslate"><span class="pre">Ansatz.set_parallel_jacobian()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.Ansatz.set_parameter_map"><code class="docutils literal notranslate"><span class="pre">Ansatz.set_parameter_map()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.Ansatz.set_sampling"><code class="docutils literal notranslate"><span class="pre">Ansatz.set_sampling()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.Ansatz.set_seed"><code class="docutils literal notranslate"><span class="pre">Ansatz.set_seed()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.Ansatz.set_unitaries"><code class="docutils literal notranslate"><span class="pre">Ansatz.set_unitaries()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.Ansatz.unset_sampling"><code class="docutils literal notranslate"><span class="pre">Ansatz.unset_sampling()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#quop_mpi.Unitary"><code class="docutils literal notranslate"><span class="pre">Unitary</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.Unitary.copy_plan"><code class="docutils literal notranslate"><span class="pre">Unitary.copy_plan()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.Unitary.destroy"><code class="docutils literal notranslate"><span class="pre">Unitary.destroy()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.Unitary.plan"><code class="docutils literal notranslate"><span class="pre">Unitary.plan()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.Unitary.propagate"><code class="docutils literal notranslate"><span class="pre">Unitary.propagate()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#algorithm">algorithm</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-quop_mpi.algorithm.combinatorial">combinatorial</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#quop_mpi.algorithm.combinatorial.qaoa"><code class="docutils literal notranslate"><span class="pre">qaoa</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#quop_mpi.algorithm.combinatorial.qwoa"><code class="docutils literal notranslate"><span class="pre">qwoa</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-quop_mpi.algorithm.multivariable">multivariable</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#quop_mpi.algorithm.multivariable.qmoa"><code class="docutils literal notranslate"><span class="pre">qmoa</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#quop_mpi.algorithm.multivariable.qowe"><code class="docutils literal notranslate"><span class="pre">qowe</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-quop_mpi.observable">observable</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.observable.array"><code class="docutils literal notranslate"><span class="pre">array()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.observable.csv"><code class="docutils literal notranslate"><span class="pre">csv()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.observable.hdf5"><code class="docutils literal notranslate"><span class="pre">hdf5()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.observable.serial"><code class="docutils literal notranslate"><span class="pre">serial()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.observable.rand.uniform"><code class="docutils literal notranslate"><span class="pre">uniform()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-quop_mpi.param">param</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.param.rand.uniform"><code class="docutils literal notranslate"><span class="pre">uniform()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-quop_mpi.state">state</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.state.array"><code class="docutils literal notranslate"><span class="pre">array()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.state.basis"><code class="docutils literal notranslate"><span class="pre">basis()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.state.equal"><code class="docutils literal notranslate"><span class="pre">equal()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.state.position_grid"><code class="docutils literal notranslate"><span class="pre">position_grid()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.state.serial"><code class="docutils literal notranslate"><span class="pre">serial()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#meta">meta</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.meta.swarm"><code class="docutils literal notranslate"><span class="pre">swarm</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#quop_mpi.meta.swarm.benchmark"><code class="docutils literal notranslate"><span class="pre">swarm.benchmark()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#quop_mpi.meta.swarm.benchmark_swarm"><code class="docutils literal notranslate"><span class="pre">swarm.benchmark_swarm()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#quop_mpi.meta.swarm.execute_swarm"><code class="docutils literal notranslate"><span class="pre">swarm.execute_swarm()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#quop_mpi.meta.swarm.get_optimal_result"><code class="docutils literal notranslate"><span class="pre">swarm.get_optimal_result()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#quop_mpi.meta.swarm.save"><code class="docutils literal notranslate"><span class="pre">swarm.save()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#quop_mpi.meta.swarm.set_log"><code class="docutils literal notranslate"><span class="pre">swarm.set_log()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#quop_mpi.meta.swarm.set_unitaries"><code class="docutils literal notranslate"><span class="pre">swarm.set_unitaries()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-quop_mpi.propagator">propagator</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-quop_mpi.propagator.circulant">circulant</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#quop_mpi.propagator.circulant.unitary"><code class="docutils literal notranslate"><span class="pre">unitary</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-quop_mpi.propagator.circulant.operator">operators</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-quop_mpi.propagator.diagonal">diagonal</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#quop_mpi.propagator.diagonal.unitary"><code class="docutils literal notranslate"><span class="pre">unitary</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#id33">operators</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-quop_mpi.propagator.sparse">sparse</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#quop_mpi.propagator.sparse.unitary"><code class="docutils literal notranslate"><span class="pre">unitary</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#id38">operators</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-quop_mpi.propagator.composite">composite</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#quop_mpi.propagator.composite.unitary"><code class="docutils literal notranslate"><span class="pre">unitary</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#id39">operators</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-quop_mpi.propagator.momentum">momentum</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#quop_mpi.propagator.momentum.unitary"><code class="docutils literal notranslate"><span class="pre">unitary</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#id40">operators</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-quop_mpi.toolkit">toolkit</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.toolkit.I"><code class="docutils literal notranslate"><span class="pre">I()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.toolkit.X"><code class="docutils literal notranslate"><span class="pre">X()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.toolkit.Y"><code class="docutils literal notranslate"><span class="pre">Y()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.toolkit.Z"><code class="docutils literal notranslate"><span class="pre">Z()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.toolkit.kron"><code class="docutils literal notranslate"><span class="pre">kron()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.toolkit.kron_power"><code class="docutils literal notranslate"><span class="pre">kron_power()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#quop_mpi.toolkit.string"><code class="docutils literal notranslate"><span class="pre">string()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="quop_functions.html">QuOp Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="developing_for_quop.html">Developing for QuOp_MPI</a></li>
<li class="toctree-l1"><a class="reference internal" href="cite.html">Citing QuOp_MPI</a></li>
<li class="toctree-l1"><a class="reference internal" href="glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="bibliography.html">Bibliography</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">QuOp_MPI</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">quop_mpi</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/quop_mpi.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="quop-mpi">
<h1>quop_mpi<a class="headerlink" href="#quop-mpi" title="Link to this heading"></a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="quop_mpi.Ansatz">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quop_mpi.</span></span><span class="sig-name descname"><span class="pre">Ansatz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">MPI_communicator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpi4py.MPI.Intracomm</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">mpi4py.MPI.COMM_WORLD</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.Ansatz" title="Link to this definition"></a></dt>
<dd><p>Define and simulate a <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVA</span></a>.</p>
<p>Associated QuOp Functions:</p>
<ul class="simple">
<li><p><a class="reference internal" href="quop_functions.html#term-Initial-State-Function"><span class="xref std std-term">Initial State Function</span></a> (<a class="reference internal" href="#quop_mpi.Ansatz.set_initial_state" title="quop_mpi.Ansatz.set_initial_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_initial_state()</span></code></a>)</p></li>
<li><p><a class="reference internal" href="quop_functions.html#term-Observables-Function"><span class="xref std std-term">Observables Function</span></a> (<a class="reference internal" href="#quop_mpi.Ansatz.set_observables" title="quop_mpi.Ansatz.set_observables"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_observables()</span></code></a>)</p></li>
<li><p><span class="xref std std-term">Free Parameters Function</span> (<code class="xref py py-meth docutils literal notranslate"><span class="pre">set_free_params()</span></code>)</p></li>
<li><p><a class="reference internal" href="quop_functions.html#term-Jacobian-Function"><span class="xref std std-term">Jacobian Function</span></a> (<a class="reference internal" href="#quop_mpi.Ansatz.set_parallel_jacobian" title="quop_mpi.Ansatz.set_parallel_jacobian"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_parallel_jacobian()</span></code></a>)</p></li>
<li><p><a class="reference internal" href="quop_functions.html#term-Sampling-Function"><span class="xref std std-term">Sampling Function</span></a> (<a class="reference internal" href="#quop_mpi.Ansatz.set_sampling" title="quop_mpi.Ansatz.set_sampling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_sampling()</span></code></a>)</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>system_size</strong><span class="classifier">int</span></dt><dd><p>number of quantum basis states in the simulated system</p>
</dd>
<dt><strong>MPI_communicator</strong><span class="classifier">Intracomm, optional</span></dt><dd><p>MPI Intracomm, by default MPI.COMM_WORLD</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Minimal definition of an arbitrary <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVA</span></a>, of size <a class="reference internal" href="glossary.html#term-system-size"><span class="xref std std-term">system size</span></a>.
Where <code class="docutils literal notranslate"><span class="pre">[UQ,</span> <span class="pre">UW]</span></code> defines the <a class="reference internal" href="glossary.html#term-ansatz-unitary"><span class="xref std std-term">ansatz unitary</span></a> and
<code class="docutils literal notranslate"><span class="pre">observable_function</span></code> is an <a class="reference internal" href="quop_functions.html#term-Observables-Function"><span class="xref std std-term">Observables Function</span></a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">alg</span> <span class="o">=</span> <span class="n">Ansatz</span><span class="p">(</span><span class="n">system_size</span><span class="p">)</span> <span class="n">alg</span><span class="o">.</span><span class="n">set_unitaries</span><span class="p">([</span><span class="n">UQ</span><span class="p">,</span> <span class="n">UW</span><span class="p">])</span>
<span class="n">alg</span><span class="o">.</span><span class="n">set_observables</span><span class="p">(</span><span class="n">observable_function</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>system_size</strong><span class="classifier">int</span></dt><dd><p>The size of the <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">simulated quantum system</span></a>.</p>
</dd>
<dt><strong>local_i</strong><span class="classifier">int</span></dt><dd><p>parallel partition size of <a class="reference internal" href="glossary.html#term-system-state"><span class="xref std std-term">system state</span></a> and <a class="reference internal" href="glossary.html#term-observables"><span class="xref std std-term">observables</span></a></p>
</dd>
<dt><strong>local_i_offset</strong><span class="classifier">int</span></dt><dd><p>global index offset of the local parallel partition</p>
</dd>
<dt><strong>partition_table</strong><span class="classifier">ndarray[int]</span></dt><dd><p>1-D integer array describing the global partitioning scheme such that
for a given MPI rank <code class="docutils literal notranslate"><span class="pre">partition_table[rank</span> <span class="pre">+</span> <span class="pre">1]</span> <span class="pre">-</span> <span class="pre">partition_table[rank]</span> <span class="pre">=</span> <span class="pre">local_i</span></code></p>
</dd>
<dt><strong>observables</strong><span class="classifier">ndarray[float64]</span></dt><dd><p>1-D real array of <code class="docutils literal notranslate"><span class="pre">local_i</span></code> <a class="reference internal" href="glossary.html#term-observables"><span class="xref std std-term">observables</span></a></p>
</dd>
<dt><strong>variational_parameters</strong><span class="classifier">ndarray[float64]</span></dt><dd><p>1-D real array of <a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational parameters</span></a>, updated during
<a class="reference internal" href="glossary.html#term-optimiser"><span class="xref std std-term">optimisation</span></a></p>
</dd>
<dt><strong>ansatz_depth</strong><span class="classifier">int</span></dt><dd><p>number of <a class="reference internal" href="glossary.html#term-ansatz-depth"><span class="xref std std-term">ansatz iterations</span></a>, by default <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
</dd>
<dt><strong>total_params</strong><span class="classifier">int</span></dt><dd><p>number of <a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational parameters</span></a> associated with each
<a class="reference internal" href="glossary.html#term-ansatz-depth"><span class="xref std std-term">ansatz iteration</span></a></p>
</dd>
<dt><strong>expectation</strong><span class="classifier">float</span></dt><dd><p>last computed <a class="reference internal" href="glossary.html#term-objective-function"><span class="xref std std-term">objective function</span></a> value, updated during
<a class="reference internal" href="glossary.html#term-optimiser"><span class="xref std std-term">optimisation</span></a></p>
</dd>
<dt><strong>ansatz_initial_state</strong><span class="classifier">ndarray[complex128]</span></dt><dd><p>1-D complex array of <code class="docutils literal notranslate"><span class="pre">local_i</span></code> values, the <a class="reference internal" href="glossary.html#term-initial-state"><span class="xref std std-term">initial system state</span></a></p>
</dd>
<dt><strong>final_state</strong><span class="classifier">ndarray[complex128]</span></dt><dd><p>1-D array of <code class="docutils literal notranslate"><span class="pre">local_i</span></code> elements, the <a class="reference internal" href="glossary.html#term-system-state"><span class="xref std std-term">system state</span></a> after
computation of the state evolution under the action of an
<a class="reference internal" href="glossary.html#term-ansatz-unitary"><span class="xref std std-term">ansatz unitary</span></a>.</p>
</dd>
<dt><strong>last_evaluated</strong><span class="classifier">ndarray[float]</span></dt><dd><p>1-D real array, the last <a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational parameters</span></a> passed to
<a class="reference internal" href="#quop_mpi.Ansatz.evolve_state" title="quop_mpi.Ansatz.evolve_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">evolve_state()</span></code></a></p>
</dd>
<dt><strong>objective_cnt</strong><span class="classifier">int</span></dt><dd><p>number of <a class="reference internal" href="glossary.html#term-objective-function"><span class="xref std std-term">objective function</span></a> evaluations during <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVA</span></a> simulation</p>
</dd>
<dt><strong>result</strong><span class="classifier">dict</span></dt><dd><p>last result returned by the  <a class="reference internal" href="#quop_mpi.Ansatz.execute" title="quop_mpi.Ansatz.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code></a> method</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int</span></dt><dd><p>seeds random number generation, incremented before each repeat in the
<a class="reference internal" href="#quop_mpi.Ansatz.benchmark" title="quop_mpi.Ansatz.benchmark"><code class="xref py py-meth docutils literal notranslate"><span class="pre">benchmark()</span></code></a> method</p>
</dd>
<dt><strong>sample_indexes</strong><span class="classifier">list[ndarray[int32]]</span></dt><dd><p>if simulating sampling, contains the global indexes for each block of
sampled <a class="reference internal" href="glossary.html#term-observables"><span class="xref std std-term">observables</span></a>, resets to <code class="docutils literal notranslate"><span class="pre">[]</span></code> when the
<a class="reference internal" href="glossary.html#term-objective-function"><span class="xref std std-term">objective function</span></a> value is accepted</p>
</dd>
<dt><strong>samples</strong><span class="classifier">list[ndarray[float64]]</span></dt><dd><p>if simulating sampling, contains the observable value for each block of
sampled <a class="reference internal" href="glossary.html#term-observables"><span class="xref std std-term">observables</span></a>, resets to <code class="docutils literal notranslate"><span class="pre">[]</span></code> when the
<a class="reference internal" href="glossary.html#term-objective-function"><span class="xref std std-term">objective function</span></a> value is accepted</p>
</dd>
<dt><strong>sample_minimum_indexes</strong><span class="classifier">list[int]</span></dt><dd><p>if simulating sampling, contains the index of the minimum
<a class="reference internal" href="glossary.html#term-observables"><span class="xref std std-term">observable</span></a> sampled for each computation
of the <a class="reference internal" href="glossary.html#term-objective-function"><span class="xref std std-term">objective function</span></a></p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.Ansatz.benchmark">
<span class="sig-name descname"><span class="pre">benchmark</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ansatz_depths</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repeats</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_parameters</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param_persist</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'test'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_action</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'a'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_limit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suspend_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.Ansatz.benchmark" title="Link to this definition"></a></dt>
<dd><p>A method by which to study how a QVA performs as the number
of ansatz iterations&lt;ansatz depth&gt; increases.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ansatz_depths</strong><span class="classifier">iterable[int]</span></dt><dd><p>integers specifying a sequence of ansatz depths&lt;ansatz depth&gt;</p>
</dd>
<dt><strong>repeats</strong><span class="classifier">int</span></dt><dd><p>number of repeats at each ansatz depth</p>
</dd>
<dt><strong>initial_parameters: list[float] or ndarray[float], optional</strong></dt><dd><p>** Must be defined if a parameter mapping function is set. **
initial variational parameter values, if not present these are generated
using the default parameter generation methods of the ansatz unitaries.</p>
</dd>
<dt><strong>param_persist</strong><span class="classifier">bool, optional</span></dt><dd><p>if True the optimised variational parameter values which achieved
the lowest objective function value for all repeats at ansatz_depth
will be used as starting parameters for the first
ansatz_depth * total_params at ansatz_depth += 1. if a parameter
map is set, the initial parameters will update whenever the 
objective function reaches a new minimum.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool, optional</span></dt><dd><p>if True, print current the ansatz depth, repeat number and
optimisation results (default True)</p>
</dd>
<dt><strong>filename</strong><span class="classifier">str or None, optional</span></dt><dd><p>name of <a href="#id1"><span class="problematic" id="id2">*</span></a>.h5 file in which to save the optimised system state and observables</p>
</dd>
<dt><strong>label</strong><span class="classifier">str, optional</span></dt><dd><p>if filename is not None, <a href="#id3"><span class="problematic" id="id4">*</span></a>.h5 data will be saved as
“filename/label_depth_repeat” (default “test”)</p>
</dd>
<dt><strong>save_action</strong><span class="classifier">{‘a’, ‘w’}, optional</span></dt><dd><p>action taken during first file write: ‘a’ to append, ‘w’ to overwrite (default ‘a’)</p>
</dd>
<dt><strong>time_limit</strong><span class="classifier">int or None, optional</span></dt><dd><p>total allocated in-program time in seconds; if exceeded, the benchmark is suspended</p>
</dd>
<dt><strong>suspend_path</strong><span class="classifier">str or None, optional</span></dt><dd><p>path to the suspend file if time_limit is not None</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.Ansatz.evaluate">
<span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variational_parameters</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#quop_mpi.Ansatz.evaluate" title="Link to this definition"></a></dt>
<dd><p>Lazily computes the <a class="reference internal" href="glossary.html#term-objective-function"><span class="xref std std-term">objective function</span></a> value.</p>
<p>The <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ansatz</span></code></a> instance stores the last <a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational
parameters</span></a> passed to <code class="docutils literal notranslate"><span class="pre">evaluate</span></code> and the corresponding objective
function value. If the input variational parameters match,
re-computation of the <a class="reference internal" href="glossary.html#term-final-state"><span class="xref std std-term">final state</span></a> is skipped and the previously
computed objective function value is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>variational_parameters</strong><span class="classifier">list[float] or ndarray[float]</span></dt><dd><p>1-D <code class="docutils literal notranslate"><span class="pre">(ansatz_depth</span> <span class="pre">*</span> <span class="pre">total_params,)</span></code> real array of variational
parameters</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>float</dt><dd><p>objective function value</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.Ansatz.evolve_state">
<span class="sig-name descname"><span class="pre">evolve_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variational_parameters</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.Ansatz.evolve_state" title="Link to this definition"></a></dt>
<dd><p>Compute the <a class="reference internal" href="glossary.html#term-system-state"><span class="xref std std-term">system state</span></a> under the action of the
<a class="reference internal" href="glossary.html#term-ansatz-unitary"><span class="xref std std-term">ansatz unitary</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>variational_parameters</strong><span class="classifier">list[float] or ndarray[float]</span></dt><dd><p>1-D <code class="docutils literal notranslate"><span class="pre">(ansatz_depth</span> <span class="pre">*</span> <span class="pre">total_params,)</span></code> real array of
<a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational parameters</span></a>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#quop_mpi.Ansatz.set_unitaries" title="quop_mpi.Ansatz.set_unitaries"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_unitaries()</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.Ansatz.execute">
<span class="sig-name descname"><span class="pre">execute</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variational_parameters</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.Ansatz.execute" title="Link to this definition"></a></dt>
<dd><p>Simulate a <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVA</span></a>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">variational_parameters</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, initial parameter values are
generated using the <a class="reference internal" href="quop_functions.html#term-Parameter-Function"><span class="xref std std-term">Parameter Function</span></a> of the corresponding
<code class="docutils literal notranslate"><span class="pre">unitary</span></code> instances.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>variational_parameters</strong><span class="classifier">list[float] or ndarray[float]</span></dt><dd><p>1-D <code class="docutils literal notranslate"><span class="pre">(ansatz_depth</span> <span class="pre">*</span> <span class="pre">total_params,)</span></code> real array of
<a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational parameters</span></a></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.Ansatz.gen_initial_params">
<span class="sig-name descname"><span class="pre">gen_initial_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ansatz_depth</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#quop_mpi.Ansatz.gen_initial_params" title="Link to this definition"></a></dt>
<dd><p>Generate initial <a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational parameters</span></a>.</p>
<p>Values are generated using the <a class="reference internal" href="quop_functions.html#term-Parameter-Function"><span class="xref std std-term">Parameter Function</span></a> associated
with each <code class="docutils literal notranslate"><span class="pre">unitary</span></code> passed to the <a class="reference internal" href="#quop_mpi.Ansatz.set_unitaries" title="quop_mpi.Ansatz.set_unitaries"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_unitaries()</span></code></a>
method.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="docutils literal notranslate"><span class="pre">ansatz_depth</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code> the <a class="reference internal" href="glossary.html#term-ansatz-depth"><span class="xref std std-term">ansatz depth</span></a> defaults 
to <cite>1</cite> or the depth specified by the <a class="reference internal" href="#quop_mpi.Ansatz.set_depth" title="quop_mpi.Ansatz.set_depth"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_depth()</span></code></a> method.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ansatz_depth</strong><span class="classifier">int, optional</span></dt><dd><p>number of <a class="reference internal" href="glossary.html#term-ansatz-depth"><span class="xref std std-term">ansatz iterations</span></a></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray[float64]</dt><dd><p>1-D <code class="docutils literal notranslate"><span class="pre">(ansatz_depth</span> <span class="pre">*</span> <span class="pre">total_params,)</span></code> real array of variational
parameters</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.Ansatz.get_expectation_value">
<span class="sig-name descname"><span class="pre">get_expectation_value</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#quop_mpi.Ansatz.get_expectation_value" title="Link to this definition"></a></dt>
<dd><p>Compute the <a class="reference internal" href="glossary.html#term-objective-function"><span class="xref std std-term">objective function</span></a> at the current
value of <code class="xref py py-meth docutils literal notranslate"><span class="pre">variational_parameters()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>float</dt><dd><p>objective function value</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.Ansatz.get_final_state">
<span class="sig-name descname"><span class="pre">get_final_state</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.complex128</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#quop_mpi.Ansatz.get_final_state" title="Link to this definition"></a></dt>
<dd><p>Gather the <a class="reference internal" href="glossary.html#term-final-state"><span class="xref std std-term">final state</span></a> to rank 0 of the <code class="docutils literal notranslate"><span class="pre">Ansatz</span></code> MPI subcommunicator.</p>
<p>Requires a previous call to <a class="reference internal" href="#quop_mpi.Ansatz.execute" title="quop_mpi.Ansatz.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code></a>, <a class="reference internal" href="#quop_mpi.Ansatz.evolve_state" title="quop_mpi.Ansatz.evolve_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">evolve_state()</span></code></a>
or <a class="reference internal" href="#quop_mpi.Ansatz.benchmark" title="quop_mpi.Ansatz.benchmark"><code class="xref py py-meth docutils literal notranslate"><span class="pre">benchmark()</span></code></a>. If called after <a class="reference internal" href="#quop_mpi.Ansatz.benchmark" title="quop_mpi.Ansatz.benchmark"><code class="xref py py-meth docutils literal notranslate"><span class="pre">benchmark()</span></code></a> the
gathered state will correspond to the last performed simulation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>ndarray[complex128] or None</dt><dd><p>the final state at rank 0 of the <code class="docutils literal notranslate"><span class="pre">Ansatz</span></code> subcommunicator, <code class="docutils literal notranslate"><span class="pre">None</span></code> otherwise</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.Ansatz.get_probabilities">
<span class="sig-name descname"><span class="pre">get_probabilities</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.float64</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#quop_mpi.Ansatz.get_probabilities" title="Link to this definition"></a></dt>
<dd><p>Gather probabilities computed from the <a class="reference internal" href="glossary.html#term-final-state"><span class="xref std std-term">final state</span></a> at rank 0
of the <code class="docutils literal notranslate"><span class="pre">Ansatz</span></code> MPI subcommunicator.</p>
<p>Requires a previous call to <a class="reference internal" href="#quop_mpi.Ansatz.execute" title="quop_mpi.Ansatz.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code></a>,
<a class="reference internal" href="#quop_mpi.Ansatz.evolve_state" title="quop_mpi.Ansatz.evolve_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">evolve_state()</span></code></a> or <a class="reference internal" href="#quop_mpi.Ansatz.benchmark" title="quop_mpi.Ansatz.benchmark"><code class="xref py py-meth docutils literal notranslate"><span class="pre">benchmark()</span></code></a>. If called after
<a class="reference internal" href="#quop_mpi.Ansatz.benchmark" title="quop_mpi.Ansatz.benchmark"><code class="xref py py-meth docutils literal notranslate"><span class="pre">benchmark()</span></code></a> the gathered state will correspond to the last
performed simulation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>ndarray[float64] or None</dt><dd><p>1-D real array of state probabilities at rank 0 of the <code class="docutils literal notranslate"><span class="pre">Ansatz</span></code>
subcommunicator, <code class="docutils literal notranslate"><span class="pre">None</span></code> otherwise</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.Ansatz.objective">
<span class="sig-name descname"><span class="pre">objective</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variational_parameters</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#quop_mpi.Ansatz.objective" title="Link to this definition"></a></dt>
<dd><p>Compute the <a class="reference internal" href="glossary.html#term-objective-function"><span class="xref std std-term">objective function</span></a> at <a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational parameters</span></a> 
<code class="docutils literal notranslate"><span class="pre">variational_parameters</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>variational_parameters</strong><span class="classifier">list or ndarray[float]</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>float</dt><dd><p>objective function value</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.Ansatz.print_optimiser_result">
<span class="sig-name descname"><span class="pre">print_optimiser_result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.Ansatz.print_optimiser_result" title="Link to this definition"></a></dt>
<dd><p>Print the result returned from the <a class="reference internal" href="glossary.html#term-optimiser"><span class="xref std std-term">optimiser</span></a> for the last
<a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVA</span></a> simulation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.Ansatz.print_result">
<span class="sig-name descname"><span class="pre">print_result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.Ansatz.print_result" title="Link to this definition"></a></dt>
<dd><p>Print a summary of the results of the last <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVA</span></a> simulation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.Ansatz.save">
<span class="sig-name descname"><span class="pre">save</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">config_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">action</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'a'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.Ansatz.save" title="Link to this definition"></a></dt>
<dd><p>Write the <a class="reference internal" href="glossary.html#term-final-state"><span class="xref std std-term">final state</span></a>, <a class="reference internal" href="glossary.html#term-observables"><span class="xref std std-term">observables</span></a> and results
summary to a HDf5 file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>file_name</strong><span class="classifier">str</span></dt><dd><p>file path to saved data</p>
</dd>
<dt><strong>config_name</strong><span class="classifier">str</span></dt><dd><p>simulation identifier</p>
</dd>
<dt><strong>action</strong><span class="classifier">{‘a’, ‘w’}, optional</span></dt><dd><p>‘a’ to append or ‘w’ to overwrite, by default ‘a’</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Data is saved into a <code class="docutils literal notranslate"><span class="pre">*.h5</span></code> file with the following structure.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>├── config_name
    ├── final_state 
    ├── observables
</pre></div>
</div>
<p>The minimization result is saved in the ‘minimize_result’ attribute of
‘config_name’ as a formatted string.</p>
<p>Multiple configurations with a unique config_name can be stored in the
same .h5 file. HDF5 files are supported in python by the <a class="reference external" href="https://www.h5py.org/">h5py</a> package. With it, a saved configuration can be
accessed as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">h5py</span>

<span class="n">config_name</span> <span class="o">=</span> <span class="s2">&quot;my_simulation&quot;</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">file_name</span> <span class="o">+</span> <span class="s2">&quot;.h5&quot;</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="n">final_state</span> <span class="o">=</span>
<span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">config_name</span><span class="p">][</span><span class="s1">&#39;final_state&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
<span class="n">eigenvalues</span> <span class="o">=</span>
<span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">config_name</span><span class="p">][</span><span class="s1">&#39;eigenvalues&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
<span class="n">observables</span> <span class="o">=</span>
<span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">config_name</span><span class="p">][</span><span class="s1">&#39;observables&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s2">&quot;my_simulation&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;minimize_result&quot;</span><span class="p">])</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The <code class="docutils literal notranslate"><span class="pre">&quot;final_state&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;observables&quot;</span></code> datasets are saved using Fortran
subroutines which make use of parallel HDF5.</p>
<p>The complex values of the final_state array are saved as a compound
datatype consisting of contiguous double precision reals. This is
equivalent to the np.complex128 NumPy datatype. To access this data
without a loss of precision in python, the user must set the
<strong>view</strong> of the NumPy array to np.complex128, rather than casting it
to np.complex128 using the dtype keyword.</p>
<p>Similarly, the observables array, which is saved as an array of
double-precision reals, should have its view set to np.float64.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.Ansatz.set_depth">
<span class="sig-name descname"><span class="pre">set_depth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">depth</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.Ansatz.set_depth" title="Link to this definition"></a></dt>
<dd><p>Set the simulated <a class="reference internal" href="glossary.html#term-ansatz-depth"><span class="xref std std-term">ansatz depth</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>depth</strong><span class="classifier">int</span></dt><dd><p>number of ansatz iterations</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.Ansatz.set_initial_state">
<span class="sig-name descname"><span class="pre">set_initial_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_state_dict</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.Ansatz.set_initial_state" title="Link to this definition"></a></dt>
<dd><p>Define the <a class="reference internal" href="glossary.html#term-initial-state"><span class="xref std std-term">initial state</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>function</strong><span class="classifier">callable</span></dt><dd><p><a class="reference internal" href="quop_functions.html#term-Initial-State-Function"><span class="xref std std-term">Initial State Function</span></a></p>
</dd>
<dt><strong>initial_state_dict</strong><span class="classifier">FunctionDict, optional</span></dt><dd><p><a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> for the Initial State Function</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.Ansatz.set_log">
<span class="sig-name descname"><span class="pre">set_log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">action</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'a'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.Ansatz.set_log" title="Link to this definition"></a></dt>
<dd><p>Creates a CSV in which to save simulation results after a call to
<a class="reference internal" href="#quop_mpi.Ansatz.execute" title="quop_mpi.Ansatz.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>path to the log file</p>
</dd>
<dt><strong>label</strong><span class="classifier">str</span></dt><dd><p>simulation identifier</p>
</dd>
<dt><strong>action</strong><span class="classifier">{‘a’, ‘w’}, optional</span></dt><dd><p>‘a’ to append or ‘w’ overwrite, by default ‘a’</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.Ansatz.set_objective">
<span class="sig-name descname"><span class="pre">set_objective</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">objective_dict</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.Ansatz.set_objective" title="Link to this definition"></a></dt>
<dd><p>Set a custom objective function (i.e. an objective function other
than the expectation value of the prepared state).</p>
<p>The function is called after state evolution - returning a scalar
value that is passed to the minimizer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>function: callable</strong></dt><dd><p>an <a class="reference internal" href="quop_functions.html#term-Objective-Function"><span class="xref std std-term">Objective Function</span></a></p>
</dd>
<dt><strong>objective_dict: FunctionDict, optional</strong></dt><dd><p><a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> for the <cite>Objective Function</cite></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.Ansatz.set_observables">
<span class="sig-name descname"><span class="pre">set_observables</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">observable_dict</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.Ansatz.set_observables" title="Link to this definition"></a></dt>
<dd><p>Specify the <a class="reference internal" href="glossary.html#term-observables"><span class="xref std std-term">observables</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>function</strong><span class="classifier">callable or int</span></dt><dd><p>an <a class="reference internal" href="quop_functions.html#term-Observables-Function"><span class="xref std std-term">Observables Function</span></a> or an integer specifying the index
of a phase-shift unitary in the list passed to the
<a class="reference internal" href="#quop_mpi.Ansatz.set_observables" title="quop_mpi.Ansatz.set_observables"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_observables()</span></code></a> whose exponent contains the
observable vector.</p>
</dd>
<dt><strong>observables_dict: FunctionDict, optional</strong></dt><dd><p><a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> for the Observables Function</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.Ansatz.set_optimiser">
<span class="sig-name descname"><span class="pre">set_optimiser</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">optimiser</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimiser_args</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimiser_log</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.Ansatz.set_optimiser" title="Link to this definition"></a></dt>
<dd><p>Define the classical <a class="reference internal" href="glossary.html#term-optimiser"><span class="xref std std-term">optimiser</span></a> for <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVA</span></a> simulation.</p>
<p>Optionally allows for specification of arguments passed to the optimiser
and fields in the optimiser dictionary to write to the log file (see
<a class="reference internal" href="#quop_mpi.Ansatz.set_log" title="quop_mpi.Ansatz.set_log"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_log()</span></code></a>). QuOp_MPI supports optimisers provided by SciPy
through its minimize method <a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html">minimize</a>
and optimisers provided by the <a class="reference external" href="http://nlopt.readthedocs.io/en/latest/">NLopt</a> package with respect to
minimisation with scalar constraints through a SciPy-like interface.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>optimiser: {‘scipy’, ‘nlopt’}</strong></dt><dd><p>‘scipy’ to use the SciPy, ‘nlopt’ to use NLopt, or a callable
QuOp_MPI-compatible optimisation function.</p>
</dd>
<dt><strong>optimiser_args: dict</strong></dt><dd><p>arguments to pass to the optimiser</p>
</dd>
<dt><strong>optimiser_log: list[str]</strong></dt><dd><p>results of the optimisation process are stored in a dictionary.
These values may be logged by passing a list of the corresponding
keys</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>The default optimiser is the BFGS algorithm, which is set internally as
follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Ansatz</span><span class="o">.</span><span class="n">set_optimiser</span><span class="p">(</span> <span class="s1">&#39;scipy&#39;</span><span class="p">,</span>
        <span class="p">{</span><span class="s1">&#39;method&#39;</span><span class="p">:</span><span class="s1">&#39;BFGS&#39;</span><span class="p">,</span><span class="s1">&#39;options&#39;</span><span class="p">:{</span><span class="s1">&#39;gtol&#39;</span><span class="p">:</span><span class="mf">1e-3</span><span class="p">}},</span>
                    <span class="p">[</span><span class="s1">&#39;fun&#39;</span><span class="p">,</span><span class="s1">&#39;nfev&#39;</span><span class="p">,</span><span class="s1">&#39;success&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.Ansatz.set_parallel_jacobian">
<span class="sig-name descname"><span class="pre">set_parallel_jacobian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes_per_subcomm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">processes_per_node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxcomm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Callable</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'forward'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.Ansatz.set_parallel_jacobian" title="Link to this definition"></a></dt>
<dd><p>Specify <a class="reference internal" href="glossary.html#term-optimiser"><span class="xref std std-term">optimisation</span></a> of the <a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational
parameters</span></a> using parallel computation of the jacobian.</p>
<p>This creates MPI subcommunicators containing duplicates of the
<a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ansatz</span></code></a> instance which return partial derivative information to
the root MPI process during optimisation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nodes_per_subcomm</strong><span class="classifier">int</span></dt><dd><p>MPI nodes per subcommunicator</p>
</dd>
<dt><strong>processes_per_node</strong><span class="classifier">int</span></dt><dd><p>MPI processors associated with each node</p>
</dd>
<dt><strong>maxcomm</strong><span class="classifier">int</span></dt><dd><p>maximum number of created MPI subcommunicators (and <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ansatz</span></code></a>
instance duplicates) if <cite>nodes_per_subcomm &gt; 1</cite>, or the maximum
number of MPI subcommunicators per node if <cite>nodes_per_subcomm = 1</cite></p>
</dd>
<dt><strong>method :{‘forward’, ‘central’} or callable, optional</strong></dt><dd><p>‘forward’ or ‘central’ to used the forward difference or central
difference method for numerical approximation of the partial
derivatives, or a QuOp Jacobian Function, by default ‘forward’</p>
</dd>
<dt><strong>h</strong><span class="classifier">float, optional</span></dt><dd><p>step-size used by the forward or central difference methods, by
default <code class="docutils literal notranslate"><span class="pre">np.sqrt(np.finfo(float).eps)</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.Ansatz.set_parameter_map">
<span class="sig-name descname"><span class="pre">set_parameter_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mapping_fn</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">np.ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">np.ndarray</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mapping_dict</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.Ansatz.set_parameter_map" title="Link to this definition"></a></dt>
<dd><p>Register a mapping from a subset of optimisable parameters to the full
set of variational parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mapping_fn</strong><span class="classifier">callable</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">mapping_fn(free_vec,</span> <span class="pre">*args,</span> <span class="pre">**kwargs)</span> <span class="pre">-&gt;</span> <span class="pre">full_vec</span></code>.
<em>free_vec</em> is the vector presented to the optimiser;
<em>full_vec</em> must have length <code class="docutils literal notranslate"><span class="pre">ansatz_depth</span> <span class="pre">*</span> <span class="pre">total_params</span></code>.</p>
</dd>
<dt><strong>mapping_dict</strong><span class="classifier">FunctionDict, optional</span></dt><dd><p>FunctionDict supplying extra positional and keyword arguments
to the mapping function.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.Ansatz.set_sampling">
<span class="sig-name descname"><span class="pre">set_sampling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample_block_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_sample_iterations</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_dict</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.Ansatz.set_sampling" title="Link to this definition"></a></dt>
<dd><p>Compute the <a class="reference internal" href="glossary.html#term-objective-function"><span class="xref std std-term">objective function</span></a> using simulated sampling.</p>
<p>Samples are taken in blocks of <cite>sample_block_size</cite>. These are passed as
a list of lists to <code class="docutils literal notranslate"><span class="pre">function</span></code> (a <a class="reference internal" href="quop_functions.html#term-Sampling-Function"><span class="xref std std-term">Sampling Function</span></a>), which returns a value for expectation
value/objective function and a boolean that indicates wether the sampled
result should be passed to the classical optimiser.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">function</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, the <a class="reference internal" href="glossary.html#term-objective-function"><span class="xref std std-term">objective function</span></a> is
computed as the mean of <code class="docutils literal notranslate"><span class="pre">sample_block_size</span></code> shots.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sample_block_size</strong><span class="classifier">int</span></dt><dd><p>number of shots taken between successive computation of the
expectation value/objective function</p>
</dd>
<dt><strong>function</strong><span class="classifier">callable, optional</span></dt><dd><p><a class="reference internal" href="quop_functions.html#term-Sampling-Function"><span class="xref std std-term">Sampling Function</span></a></p>
</dd>
<dt><strong>max_sample_iterations</strong><span class="classifier">int, optional</span></dt><dd><p>maximum number of sample blocks per computation of the expectation
value/objective function,  overrides the boolean returned by
<code class="docutils literal notranslate"><span class="pre">function</span></code>, by default 100</p>
</dd>
<dt><strong>sampling_dict</strong><span class="classifier">FunctionDict, optional</span></dt><dd><p><a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> for the Sampling Function</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.Ansatz.set_seed">
<span class="sig-name descname"><span class="pre">set_seed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.Ansatz.set_seed" title="Link to this definition"></a></dt>
<dd><p>Integer for seeding of random number generation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>seed</strong><span class="classifier">int</span></dt><dd><p>seeds the generation of random parameters</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.Ansatz.set_unitaries">
<span class="sig-name descname"><span class="pre">set_unitaries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unitaries</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#quop_mpi.Unitary" title="quop_mpi.Unitary.Unitary"><span class="pre">Unitary</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.Ansatz.set_unitaries" title="Link to this definition"></a></dt>
<dd><p>Define the <a class="reference internal" href="glossary.html#term-ansatz-unitary"><span class="xref std std-term">ansatz unitary</span></a>.</p>
<blockquote>
<div><p><a class="reference internal" href="glossary.html#term-unitary"><span class="xref std std-term">Unitaries</span></a> are passed as a python list in order of
application from left to right.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>unitaries: list[unitary]</strong></dt><dd><p>list of <a class="reference internal" href="glossary.html#term-unitary"><span class="xref std std-term">unitaries</span></a> specifying the action of one
<a class="reference internal" href="glossary.html#term-ansatz-depth"><span class="xref std std-term">ansatz iteration</span></a></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.Ansatz.unset_sampling">
<span class="sig-name descname"><span class="pre">unset_sampling</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.Ansatz.unset_sampling" title="Link to this definition"></a></dt>
<dd><p>Revert to simulation using exact computation of the
<a class="reference internal" href="glossary.html#term-objective-function"><span class="xref std std-term">objective function</span></a>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="quop_mpi.Unitary">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quop_mpi.</span></span><span class="sig-name descname"><span class="pre">Unitary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operator_function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator_n_params</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator_dict</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parameter_function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param_dict</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unitary_n_params</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.Unitary" title="Link to this definition"></a></dt>
<dd><p>Base class for a <code class="docutils literal notranslate"><span class="pre">unitary</span></code>.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">unitary</span></code> is derived from the <code class="docutils literal notranslate"><span class="pre">Unitary</span></code> class and implements
simulation of a specfic <a class="reference internal" href="glossary.html#term-unitary"><span class="xref std std-term">unitary</span></a> through definition of the following
methods:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#quop_mpi.Unitary.propagate" title="quop_mpi.Unitary.propagate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">propagate()</span></code></a></p></li>
<li><p><a class="reference internal" href="#quop_mpi.Unitary.plan" title="quop_mpi.Unitary.plan"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plan()</span></code></a></p></li>
<li><p><a class="reference internal" href="#quop_mpi.Unitary.copy_plan" title="quop_mpi.Unitary.copy_plan"><code class="xref py py-meth docutils literal notranslate"><span class="pre">copy_plan()</span></code></a></p></li>
<li><p><a class="reference internal" href="#quop_mpi.Unitary.destroy" title="quop_mpi.Unitary.destroy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">destroy()</span></code></a></p></li>
</ul>
<p>A list of <code class="docutils literal notranslate"><span class="pre">unitary</span></code> instances passed to
<a class="reference internal" href="#quop_mpi.Ansatz.set_unitaries" title="quop_mpi.Ansatz.set_unitaries"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quop_mpi.Ansatz.set_unitaries()</span></code></a> defines the <a class="reference internal" href="glossary.html#term-ansatz-unitary"><span class="xref std std-term">ansatz unitary</span></a> of
a <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVA</span></a>. After initialisation, <code class="docutils literal notranslate"><span class="pre">unitary</span></code> instances are managed by the
<a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a> class and calls to <code class="docutils literal notranslate"><span class="pre">unitary</span></code> methods are not made
explicitly.</p>
<p>See <a class="reference internal" href="#module-quop_mpi.propagator" title="quop_mpi.propagator"><code class="xref py py-mod docutils literal notranslate"><span class="pre">quop_mpi.propagator</span></code></a> for predefined <code class="docutils literal notranslate"><span class="pre">unitary</span></code> subclasses.</p>
<p>Associated QuOp Functions:</p>
<ul class="simple">
<li><p><a class="reference internal" href="quop_functions.html#term-Operator-Function"><span class="xref std std-term">Operator Function</span></a></p></li>
<li><p><a class="reference internal" href="quop_functions.html#term-Parameter-Function"><span class="xref std std-term">Parameter Function</span></a></p></li>
</ul>
<p>The following attributes are common to all <code class="docutils literal notranslate"><span class="pre">unitary</span></code> instances.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>final_state</strong></dt><dd><p>The <a class="reference internal" href="glossary.html#term-system-state"><span class="xref std std-term">system state</span></a> after the action of the unitary.</p>
</dd>
<dt><strong>initial_parameters</strong></dt><dd><p>Initial <a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational parameters</span></a> returned from the user-defined
<a class="reference internal" href="quop_functions.html#term-Parameter-Function"><span class="xref std std-term">Parameter Function</span></a>.</p>
</dd>
<dt><strong>initial_state</strong></dt><dd><p>The <a class="reference internal" href="glossary.html#term-initial-state"><span class="xref std std-term">initial state</span></a> of the quantum system.</p>
</dd>
<dt><strong>n_params</strong></dt><dd><p>The total number of <a class="reference internal" href="glossary.html#term-unitary-parameter"><span class="xref std std-term">unitary</span></a> and
<a class="reference internal" href="glossary.html#term-operator-parameter"><span class="xref std std-term">operator</span></a> parameterising the
<a class="reference internal" href="glossary.html#term-unitary"><span class="xref std std-term">unitary</span></a>.</p>
</dd>
<dt><strong>operator_function</strong></dt><dd><p>The user-defined <a class="reference internal" href="quop_functions.html#term-Operator-Function"><span class="xref std std-term">Operator Function</span></a>.</p>
</dd>
<dt><strong>operator_dict</strong></dt><dd><p>A <a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> of additional position and keyword arguments for
the <a class="reference internal" href="quop_functions.html#term-Operator-Function"><span class="xref std std-term">Operator Function</span></a>.</p>
</dd>
<dt><strong>operator</strong></dt><dd><p>The <a class="reference internal" href="glossary.html#term-operator"><span class="xref std std-term">operator</span></a> object returned by the <a class="reference internal" href="quop_functions.html#term-Operator-Function"><span class="xref std std-term">Operator Function</span></a>.</p>
</dd>
<dt><strong>operator_n_params</strong></dt><dd><p>Number of variational <a class="reference internal" href="glossary.html#term-operator-parameter"><span class="xref std std-term">operator parameters</span></a>.</p>
</dd>
<dt><strong>parameter_function</strong></dt><dd><p>The user-defined <a class="reference internal" href="quop_functions.html#term-Parameter-Function"><span class="xref std std-term">Parameter Function</span></a>.</p>
</dd>
<dt><strong>param_dict</strong></dt><dd><p>A <a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> of additional position and keyword arguments for
the <a class="reference internal" href="quop_functions.html#term-Parameter-Function"><span class="xref std std-term">Parameter Function</span></a>.</p>
</dd>
<dt><strong>planner</strong></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the parallel partitioning scheme returned by
<a class="reference internal" href="#quop_mpi.Unitary.plan" title="quop_mpi.Unitary.plan"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plan()</span></code></a> takes precedence over non-planner <code class="docutils literal notranslate"><span class="pre">unitaries</span></code>
and <code class="docutils literal notranslate"><span class="pre">unitaries</span></code> that appear later in the <a class="reference internal" href="glossary.html#term-ansatz-unitary"><span class="xref std std-term">ansatz unitary</span></a> list
supplied to <a class="reference internal" href="#quop_mpi.Ansatz.set_unitaries" title="quop_mpi.Ansatz.set_unitaries"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quop_mpi.Ansatz.set_unitaries()</span></code></a>.</p>
</dd>
<dt><strong>seed</strong></dt><dd><p>Integer for seeding random number generation, shared with
<a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a>.</p>
</dd>
<dt><strong>system_size</strong></dt><dd><p>The size of the <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">simulated quantum system</span></a>, shared with
<a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a>.</p>
</dd>
<dt><strong>unitary_n_params</strong></dt><dd><p>The number of <a class="reference internal" href="glossary.html#term-unitary-parameter"><span class="xref std std-term">unitary parameters</span></a>.</p>
</dd>
<dt><strong>unitary_type</strong></dt><dd><p>A string labeling the <code class="docutils literal notranslate"><span class="pre">unitary</span></code> type (e.g. “diagonal” or “sparse”).</p>
</dd>
<dt><strong>variational_parameters</strong></dt><dd><p><a class="reference internal" href="glossary.html#term-operator-parameter"><span class="xref std std-term">Operator variational parameters</span></a>. If present
as an argument of the <a class="reference internal" href="quop_functions.html#term-Operator-Function"><span class="xref std std-term">Operator Function</span></a>, a real array of size
<code class="docutils literal notranslate"><span class="pre">operator_n_params</span></code> is passed to the <a class="reference internal" href="quop_functions.html#term-Operator-Function"><span class="xref std std-term">Operator Function</span></a>.</p>
</dd>
<dt><strong>MPI_COMM</strong></dt><dd><p>MPI Intracommunicator, shared with <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a>.</p>
</dd>
<dt><strong>alloc_local</strong></dt><dd><p>The size of the array storing the :term`operator` if the operator is an
array (equal to <code class="docutils literal notranslate"><span class="pre">local_i</span></code> otherwise). The second return value of
<a class="reference internal" href="#quop_mpi.Unitary.plan" title="quop_mpi.Unitary.plan"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plan()</span></code></a>.</p>
</dd>
<dt><strong>lb</strong></dt><dd><p>The lower global index of the local <a class="reference internal" href="glossary.html#term-system-state"><span class="xref std std-term">system state</span></a> partition.</p>
</dd>
<dt><strong>ub</strong></dt><dd><p>The upper global index of the local <a class="reference internal" href="glossary.html#term-system-state"><span class="xref std std-term">system state</span></a> partition.</p>
</dd>
<dt><strong>local_i</strong></dt><dd><p>The size of the local <a class="reference internal" href="glossary.html#term-system-state"><span class="xref std std-term">system state</span></a> partition. The first return
value of <a class="reference internal" href="#quop_mpi.Unitary.plan" title="quop_mpi.Unitary.plan"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plan()</span></code></a></p>
</dd>
<dt><strong>local_i_offset</strong></dt><dd><p>The global index offset of the local <a class="reference internal" href="glossary.html#term-system-state"><span class="xref std std-term">system state</span></a> partition.</p>
</dd>
<dt><strong>partition_table</strong></dt><dd><p>1-D integer array describing the global partitioning scheme such that
for a given MPI rank <code class="docutils literal notranslate"><span class="pre">partition_table[rank</span> <span class="pre">+</span> <span class="pre">1]</span> <span class="pre">-</span> <span class="pre">partition_table[rank]</span>
<span class="pre">=</span> <span class="pre">local_i</span></code></p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.Unitary.copy_plan">
<span class="sig-name descname"><span class="pre">copy_plan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ex_unitary</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#quop_mpi.Unitary" title="quop_mpi.Unitary.Unitary"><span class="pre">Unitary</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.Unitary.copy_plan" title="Link to this definition"></a></dt>
<dd><p>Perform any setup required by the propagation method called in
<a class="reference internal" href="#quop_mpi.Unitary.propagate" title="quop_mpi.Unitary.propagate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">propagate()</span></code></a>.</p>
<p>When implemented, <code class="docutils literal notranslate"><span class="pre">copy_plan</span></code> performs the same internal operations as
<a class="reference internal" href="#quop_mpi.Unitary.plan" title="quop_mpi.Unitary.plan"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plan()</span></code></a> using the <code class="docutils literal notranslate"><span class="pre">local_i</span></code> and <code class="docutils literal notranslate"><span class="pre">alloc_local</span></code>
attributes of <code class="docutils literal notranslate"><span class="pre">ex_unitary</span></code>. Does <strong>not</strong> return <code class="docutils literal notranslate"><span class="pre">[local_i,</span>
<span class="pre">alloc_local]</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Not implemented by the base <code class="docutils literal notranslate"><span class="pre">Unitary</span></code> class.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ex_unitary</strong><span class="classifier">unitary</span></dt><dd><p>a <code class="docutils literal notranslate"><span class="pre">unitary</span></code> instance with computed <code class="docutils literal notranslate"><span class="pre">local_i</span></code> and <code class="docutils literal notranslate"><span class="pre">alloc_local</span></code>
attributes</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.Unitary.destroy">
<span class="sig-name descname"><span class="pre">destroy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.Unitary.destroy" title="Link to this definition"></a></dt>
<dd><p>Free memory allocated by Python extension modules in
<a class="reference internal" href="#quop_mpi.Unitary.plan" title="quop_mpi.Unitary.plan"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plan()</span></code></a> or <a class="reference internal" href="#quop_mpi.Unitary.copy_plan" title="quop_mpi.Unitary.copy_plan"><code class="xref py py-meth docutils literal notranslate"><span class="pre">copy_plan()</span></code></a>. collector.</p>
<p>Memory allocated by compiled Python extension modules is typically not
managed by the Python garbage collector. These allocations must be freed
via relevant methods in the extension module to prevent the occurrence
of <a class="reference external" href="https://en.wikipedia.org/wiki/Memory_leak">memory leaks</a>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Not implemented by the base <code class="docutils literal notranslate"><span class="pre">Unitary</span></code> class.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.Unitary.plan">
<span class="sig-name descname"><span class="pre">plan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">MPI_COMM</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpi4py.MPI.Intracomm</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.Unitary.plan" title="Link to this definition"></a></dt>
<dd><p>Plan the partitioning scheme used by an <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a>
instance and performs any other tasks required by
<a class="reference internal" href="#quop_mpi.Unitary.propagate" title="quop_mpi.Unitary.propagate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">propagate()</span></code></a>.</p>
<p>An implemented <code class="docutils literal notranslate"><span class="pre">plan</span></code> returns (<code class="docutils literal notranslate"><span class="pre">local_i</span></code>, <code class="docutils literal notranslate"><span class="pre">alloc_local</span></code>). Data
structures and allocation required by the propagation method called in
<a class="reference internal" href="#quop_mpi.Unitary.propagate" title="quop_mpi.Unitary.propagate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">propagate()</span></code></a> are assigned to attributes of the <code class="docutils literal notranslate"><span class="pre">Unitary</span></code>
instance.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">alloc_local</span></code> return value specifies the size of the local
<a class="reference internal" href="glossary.html#term-system-state"><span class="xref std std-term">system state</span></a> arrays <code class="docutils literal notranslate"><span class="pre">initial_state</span></code> and <code class="docutils literal notranslate"><span class="pre">final_state</span></code>. In
most cases <code class="docutils literal notranslate"><span class="pre">alloc_local</span> <span class="pre">==</span> <span class="pre">local_i</span></code>, however <code class="docutils literal notranslate"><span class="pre">alloc_local</span> <span class="pre">&gt;</span> <span class="pre">local_i</span></code>
may be required by particular external propagation methods (e.g. the
parallel FFTW).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Not implemented by the base <code class="docutils literal notranslate"><span class="pre">Unitary</span></code> class.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>system_size</strong><span class="classifier">int</span></dt><dd><p>size of the simulated quantum <a class="reference internal" href="glossary.html#term-system-state"><span class="xref std std-term">system</span></a>.</p>
</dd>
<dt><strong>MPI_COMM</strong><span class="classifier">Intracomm</span></dt><dd><p>MPI communicator over which the <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ansatz</span></code></a> <a class="reference internal" href="glossary.html#term-observables"><span class="xref std std-term">observables</span></a>,
<a class="reference internal" href="glossary.html#term-initial-state"><span class="xref std std-term">initial state</span></a> and <a class="reference internal" href="glossary.html#term-final-state"><span class="xref std std-term">final state</span></a> are partitioned.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>(int, int)</dt><dd><p>number of elements in a row-wise partitioning of the system state
and size to allocate for the <code class="docutils literal notranslate"><span class="pre">initial_state</span></code> and <code class="docutils literal notranslate"><span class="pre">final_state</span></code>
arrays</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">plan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">system_size</span><span class="p">,</span> <span class="n">MPI_COMM</span><span class="p">):</span>

    <span class="n">local_i</span> <span class="o">=</span> <span class="n">system_size</span>  <span class="o">//</span> <span class="n">MPI_COMM</span><span class="o">.</span><span class="n">size</span>

    <span class="n">local_i</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">system_size</span> <span class="o">-</span> <span class="n">local_i</span> <span class="o">*</span> <span class="n">MPI_COMM</span><span class="o">.</span><span class="n">rank</span> <span class="k">if</span> <span class="n">MPI_COMM</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">else</span> <span class="n">local_i</span>
    <span class="p">)</span>

    <span class="n">alloc_local</span> <span class="o">=</span> <span class="n">local_i</span>

    <span class="k">return</span> <span class="n">local_i</span><span class="p">,</span> <span class="n">alloc_local</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.Unitary.propagate">
<span class="sig-name descname"><span class="pre">propagate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.float64</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.Unitary.propagate" title="Link to this definition"></a></dt>
<dd><p>Simulation of the action of a :term`unitary`.</p>
<p>When implemented, <code class="docutils literal notranslate"><span class="pre">propagate</span></code> contains a call to a method (typically a
contained in a complied Python extension module) that takes the class
attributes <code class="docutils literal notranslate"><span class="pre">initial_state</span></code>, <code class="docutils literal notranslate"><span class="pre">final_state</span></code> and <code class="docutils literal notranslate"><span class="pre">MPI_COMM</span></code>, together
with attributes describing the parallel partitioning scheme and
<a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational parameters</span></a> <code class="docutils literal notranslate"><span class="pre">x</span></code>, as input. The action of the unitary
is computed in MPI parallel, with the computed result written to
<code class="docutils literal notranslate"><span class="pre">final_state</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Not implemented by the base <code class="docutils literal notranslate"><span class="pre">Unitary</span></code> class.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">ndarray[float64]</span></dt><dd><p>a 1-D real array of <code class="docutils literal notranslate"><span class="pre">n_params</span></code> <a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational parameters</span></a></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">propagate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>

    <span class="n">external_propagator</span><span class="p">(</span>
        <span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition_table</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_state</span><span class="p">,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final_state</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">MPI_COMM</span> <span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<section id="algorithm">
<h2>algorithm<a class="headerlink" href="#algorithm" title="Link to this heading"></a></h2>
<section id="module-quop_mpi.algorithm.combinatorial">
<span id="combinatorial"></span><h3>combinatorial<a class="headerlink" href="#module-quop_mpi.algorithm.combinatorial" title="Link to this heading"></a></h3>
<p>Predefined <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVAs</span></a> for combinatorial optimisation problems.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The following compatible <a class="reference internal" href="quop_functions.html#term-Operator-Function"><span class="xref std std-term">Operator Functions</span></a> may be imported from the <a class="reference internal" href="#module-quop_mpi.algorithm.combinatorial" title="quop_mpi.algorithm.combinatorial"><code class="xref py py-mod docutils literal notranslate"><span class="pre">combinatorial</span></code></a>:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#quop_mpi.propagator.diagonal.operator.serial" title="quop_mpi.propagator.diagonal.operator.serial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">serial()</span></code></a></p></li>
<li><p><a class="reference internal" href="#quop_mpi.propagator.diagonal.operator.csv" title="quop_mpi.propagator.diagonal.operator.csv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">csv()</span></code></a></p></li>
<li><p><a class="reference internal" href="#quop_mpi.propagator.diagonal.operator.hdf5" title="quop_mpi.propagator.diagonal.operator.hdf5"><code class="xref py py-meth docutils literal notranslate"><span class="pre">hdf5()</span></code></a></p></li>
<li><p><a class="reference internal" href="#quop_mpi.propagator.diagonal.operator.array" title="quop_mpi.propagator.diagonal.operator.array"><code class="xref py py-meth docutils literal notranslate"><span class="pre">array()</span></code></a></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">uniform()</span></code></p></li>
</ul>
</div></blockquote>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qaoa">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quop_mpi.algorithm.combinatorial.</span></span><span class="sig-name descname"><span class="pre">qaoa</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">MPI_communicator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpi4py.MPI.Intracomm</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">mpi4py.MPI.COMM_WORLD</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qaoa" title="Link to this definition"></a></dt>
<dd><p>Simulate the <a class="reference internal" href="theoretical_background.html#qaoa"><span class="std std-ref">QAOA</span></a>.</p>
<p>See <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>system_size</strong><span class="classifier">int</span></dt><dd><p><a class="reference internal" href="glossary.html#term-system-size"><span class="xref std std-term">system size</span></a> of the simulated <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVA</span></a></p>
</dd>
<dt><strong>MPI_COMM</strong><span class="classifier">Intracomm, optional</span></dt><dd><p>MPI communicator, default <code class="docutils literal notranslate"><span class="pre">mpi4py.MPI.COMM_WORLD</span></code></p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qaoa.benchmark">
<span class="sig-name descname"><span class="pre">benchmark</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ansatz_depths</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repeats</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_parameters</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param_persist</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'test'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_action</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'a'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_limit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suspend_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qaoa.benchmark" title="Link to this definition"></a></dt>
<dd><p>A method by which to study how a QVA performs as the number
of ansatz iterations&lt;ansatz depth&gt; increases.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ansatz_depths</strong><span class="classifier">iterable[int]</span></dt><dd><p>integers specifying a sequence of ansatz depths&lt;ansatz depth&gt;</p>
</dd>
<dt><strong>repeats</strong><span class="classifier">int</span></dt><dd><p>number of repeats at each ansatz depth</p>
</dd>
<dt><strong>initial_parameters: list[float] or ndarray[float], optional</strong></dt><dd><p>** Must be defined if a parameter mapping function is set. **
initial variational parameter values, if not present these are generated
using the default parameter generation methods of the ansatz unitaries.</p>
</dd>
<dt><strong>param_persist</strong><span class="classifier">bool, optional</span></dt><dd><p>if True the optimised variational parameter values which achieved
the lowest objective function value for all repeats at ansatz_depth
will be used as starting parameters for the first
ansatz_depth * total_params at ansatz_depth += 1. if a parameter
map is set, the initial parameters will update whenever the 
objective function reaches a new minimum.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool, optional</span></dt><dd><p>if True, print current the ansatz depth, repeat number and
optimisation results (default True)</p>
</dd>
<dt><strong>filename</strong><span class="classifier">str or None, optional</span></dt><dd><p>name of <a href="#id5"><span class="problematic" id="id6">*</span></a>.h5 file in which to save the optimised system state and observables</p>
</dd>
<dt><strong>label</strong><span class="classifier">str, optional</span></dt><dd><p>if filename is not None, <a href="#id7"><span class="problematic" id="id8">*</span></a>.h5 data will be saved as
“filename/label_depth_repeat” (default “test”)</p>
</dd>
<dt><strong>save_action</strong><span class="classifier">{‘a’, ‘w’}, optional</span></dt><dd><p>action taken during first file write: ‘a’ to append, ‘w’ to overwrite (default ‘a’)</p>
</dd>
<dt><strong>time_limit</strong><span class="classifier">int or None, optional</span></dt><dd><p>total allocated in-program time in seconds; if exceeded, the benchmark is suspended</p>
</dd>
<dt><strong>suspend_path</strong><span class="classifier">str or None, optional</span></dt><dd><p>path to the suspend file if time_limit is not None</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qaoa.evaluate">
<span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variational_parameters</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qaoa.evaluate" title="Link to this definition"></a></dt>
<dd><p>Lazily computes the <a class="reference internal" href="glossary.html#term-objective-function"><span class="xref std std-term">objective function</span></a> value.</p>
<p>The <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ansatz</span></code></a> instance stores the last <a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational
parameters</span></a> passed to <code class="docutils literal notranslate"><span class="pre">evaluate</span></code> and the corresponding objective
function value. If the input variational parameters match,
re-computation of the <a class="reference internal" href="glossary.html#term-final-state"><span class="xref std std-term">final state</span></a> is skipped and the previously
computed objective function value is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>variational_parameters</strong><span class="classifier">list[float] or ndarray[float]</span></dt><dd><p>1-D <code class="docutils literal notranslate"><span class="pre">(ansatz_depth</span> <span class="pre">*</span> <span class="pre">total_params,)</span></code> real array of variational
parameters</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>float</dt><dd><p>objective function value</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qaoa.evolve_state">
<span class="sig-name descname"><span class="pre">evolve_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variational_parameters</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qaoa.evolve_state" title="Link to this definition"></a></dt>
<dd><p>Compute the <a class="reference internal" href="glossary.html#term-system-state"><span class="xref std std-term">system state</span></a> under the action of the
<a class="reference internal" href="glossary.html#term-ansatz-unitary"><span class="xref std std-term">ansatz unitary</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>variational_parameters</strong><span class="classifier">list[float] or ndarray[float]</span></dt><dd><p>1-D <code class="docutils literal notranslate"><span class="pre">(ansatz_depth</span> <span class="pre">*</span> <span class="pre">total_params,)</span></code> real array of
<a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational parameters</span></a>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#quop_mpi.Ansatz.set_unitaries" title="quop_mpi.Ansatz.set_unitaries"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_unitaries()</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qaoa.execute">
<span class="sig-name descname"><span class="pre">execute</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variational_parameters</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qaoa.execute" title="Link to this definition"></a></dt>
<dd><p>Simulate a <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVA</span></a>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">variational_parameters</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, initial parameter values are
generated using the <a class="reference internal" href="quop_functions.html#term-Parameter-Function"><span class="xref std std-term">Parameter Function</span></a> of the corresponding
<code class="docutils literal notranslate"><span class="pre">unitary</span></code> instances.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>variational_parameters</strong><span class="classifier">list[float] or ndarray[float]</span></dt><dd><p>1-D <code class="docutils literal notranslate"><span class="pre">(ansatz_depth</span> <span class="pre">*</span> <span class="pre">total_params,)</span></code> real array of
<a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational parameters</span></a></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qaoa.gen_initial_params">
<span class="sig-name descname"><span class="pre">gen_initial_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ansatz_depth</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qaoa.gen_initial_params" title="Link to this definition"></a></dt>
<dd><p>Generate initial <a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational parameters</span></a>.</p>
<p>Values are generated using the <a class="reference internal" href="quop_functions.html#term-Parameter-Function"><span class="xref std std-term">Parameter Function</span></a> associated
with each <code class="docutils literal notranslate"><span class="pre">unitary</span></code> passed to the <a class="reference internal" href="#quop_mpi.Ansatz.set_unitaries" title="quop_mpi.Ansatz.set_unitaries"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_unitaries()</span></code></a>
method.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="docutils literal notranslate"><span class="pre">ansatz_depth</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code> the <a class="reference internal" href="glossary.html#term-ansatz-depth"><span class="xref std std-term">ansatz depth</span></a> defaults 
to <cite>1</cite> or the depth specified by the <a class="reference internal" href="#quop_mpi.Ansatz.set_depth" title="quop_mpi.Ansatz.set_depth"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_depth()</span></code></a> method.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ansatz_depth</strong><span class="classifier">int, optional</span></dt><dd><p>number of <a class="reference internal" href="glossary.html#term-ansatz-depth"><span class="xref std std-term">ansatz iterations</span></a></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray[float64]</dt><dd><p>1-D <code class="docutils literal notranslate"><span class="pre">(ansatz_depth</span> <span class="pre">*</span> <span class="pre">total_params,)</span></code> real array of variational
parameters</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qaoa.get_expectation_value">
<span class="sig-name descname"><span class="pre">get_expectation_value</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qaoa.get_expectation_value" title="Link to this definition"></a></dt>
<dd><p>Compute the <a class="reference internal" href="glossary.html#term-objective-function"><span class="xref std std-term">objective function</span></a> at the current
value of <code class="xref py py-meth docutils literal notranslate"><span class="pre">variational_parameters()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>float</dt><dd><p>objective function value</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qaoa.get_final_state">
<span class="sig-name descname"><span class="pre">get_final_state</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.complex128</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qaoa.get_final_state" title="Link to this definition"></a></dt>
<dd><p>Gather the <a class="reference internal" href="glossary.html#term-final-state"><span class="xref std std-term">final state</span></a> to rank 0 of the <code class="docutils literal notranslate"><span class="pre">Ansatz</span></code> MPI subcommunicator.</p>
<p>Requires a previous call to <a class="reference internal" href="#quop_mpi.Ansatz.execute" title="quop_mpi.Ansatz.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code></a>, <a class="reference internal" href="#quop_mpi.Ansatz.evolve_state" title="quop_mpi.Ansatz.evolve_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">evolve_state()</span></code></a>
or <a class="reference internal" href="#quop_mpi.Ansatz.benchmark" title="quop_mpi.Ansatz.benchmark"><code class="xref py py-meth docutils literal notranslate"><span class="pre">benchmark()</span></code></a>. If called after <a class="reference internal" href="#quop_mpi.Ansatz.benchmark" title="quop_mpi.Ansatz.benchmark"><code class="xref py py-meth docutils literal notranslate"><span class="pre">benchmark()</span></code></a> the
gathered state will correspond to the last performed simulation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>ndarray[complex128] or None</dt><dd><p>the final state at rank 0 of the <code class="docutils literal notranslate"><span class="pre">Ansatz</span></code> subcommunicator, <code class="docutils literal notranslate"><span class="pre">None</span></code> otherwise</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qaoa.get_probabilities">
<span class="sig-name descname"><span class="pre">get_probabilities</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.float64</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qaoa.get_probabilities" title="Link to this definition"></a></dt>
<dd><p>Gather probabilities computed from the <a class="reference internal" href="glossary.html#term-final-state"><span class="xref std std-term">final state</span></a> at rank 0
of the <code class="docutils literal notranslate"><span class="pre">Ansatz</span></code> MPI subcommunicator.</p>
<p>Requires a previous call to <a class="reference internal" href="#quop_mpi.Ansatz.execute" title="quop_mpi.Ansatz.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code></a>,
<a class="reference internal" href="#quop_mpi.Ansatz.evolve_state" title="quop_mpi.Ansatz.evolve_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">evolve_state()</span></code></a> or <a class="reference internal" href="#quop_mpi.Ansatz.benchmark" title="quop_mpi.Ansatz.benchmark"><code class="xref py py-meth docutils literal notranslate"><span class="pre">benchmark()</span></code></a>. If called after
<a class="reference internal" href="#quop_mpi.Ansatz.benchmark" title="quop_mpi.Ansatz.benchmark"><code class="xref py py-meth docutils literal notranslate"><span class="pre">benchmark()</span></code></a> the gathered state will correspond to the last
performed simulation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>ndarray[float64] or None</dt><dd><p>1-D real array of state probabilities at rank 0 of the <code class="docutils literal notranslate"><span class="pre">Ansatz</span></code>
subcommunicator, <code class="docutils literal notranslate"><span class="pre">None</span></code> otherwise</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qaoa.objective">
<span class="sig-name descname"><span class="pre">objective</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variational_parameters</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qaoa.objective" title="Link to this definition"></a></dt>
<dd><p>Compute the <a class="reference internal" href="glossary.html#term-objective-function"><span class="xref std std-term">objective function</span></a> at <a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational parameters</span></a> 
<code class="docutils literal notranslate"><span class="pre">variational_parameters</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>variational_parameters</strong><span class="classifier">list or ndarray[float]</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>float</dt><dd><p>objective function value</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qaoa.print_optimiser_result">
<span class="sig-name descname"><span class="pre">print_optimiser_result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qaoa.print_optimiser_result" title="Link to this definition"></a></dt>
<dd><p>Print the result returned from the <a class="reference internal" href="glossary.html#term-optimiser"><span class="xref std std-term">optimiser</span></a> for the last
<a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVA</span></a> simulation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qaoa.print_result">
<span class="sig-name descname"><span class="pre">print_result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qaoa.print_result" title="Link to this definition"></a></dt>
<dd><p>Print a summary of the results of the last <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVA</span></a> simulation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qaoa.save">
<span class="sig-name descname"><span class="pre">save</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">config_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">action</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'a'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qaoa.save" title="Link to this definition"></a></dt>
<dd><p>Write the <a class="reference internal" href="glossary.html#term-final-state"><span class="xref std std-term">final state</span></a>, <a class="reference internal" href="glossary.html#term-observables"><span class="xref std std-term">observables</span></a> and results
summary to a HDf5 file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>file_name</strong><span class="classifier">str</span></dt><dd><p>file path to saved data</p>
</dd>
<dt><strong>config_name</strong><span class="classifier">str</span></dt><dd><p>simulation identifier</p>
</dd>
<dt><strong>action</strong><span class="classifier">{‘a’, ‘w’}, optional</span></dt><dd><p>‘a’ to append or ‘w’ to overwrite, by default ‘a’</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Data is saved into a <code class="docutils literal notranslate"><span class="pre">*.h5</span></code> file with the following structure.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>├── config_name
    ├── final_state 
    ├── observables
</pre></div>
</div>
<p>The minimization result is saved in the ‘minimize_result’ attribute of
‘config_name’ as a formatted string.</p>
<p>Multiple configurations with a unique config_name can be stored in the
same .h5 file. HDF5 files are supported in python by the <a class="reference external" href="https://www.h5py.org/">h5py</a> package. With it, a saved configuration can be
accessed as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">h5py</span>

<span class="n">config_name</span> <span class="o">=</span> <span class="s2">&quot;my_simulation&quot;</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">file_name</span> <span class="o">+</span> <span class="s2">&quot;.h5&quot;</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="n">final_state</span> <span class="o">=</span>
<span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">config_name</span><span class="p">][</span><span class="s1">&#39;final_state&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
<span class="n">eigenvalues</span> <span class="o">=</span>
<span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">config_name</span><span class="p">][</span><span class="s1">&#39;eigenvalues&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
<span class="n">observables</span> <span class="o">=</span>
<span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">config_name</span><span class="p">][</span><span class="s1">&#39;observables&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s2">&quot;my_simulation&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;minimize_result&quot;</span><span class="p">])</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The <code class="docutils literal notranslate"><span class="pre">&quot;final_state&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;observables&quot;</span></code> datasets are saved using Fortran
subroutines which make use of parallel HDF5.</p>
<p>The complex values of the final_state array are saved as a compound
datatype consisting of contiguous double precision reals. This is
equivalent to the np.complex128 NumPy datatype. To access this data
without a loss of precision in python, the user must set the
<strong>view</strong> of the NumPy array to np.complex128, rather than casting it
to np.complex128 using the dtype keyword.</p>
<p>Similarly, the observables array, which is saved as an array of
double-precision reals, should have its view set to np.float64.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qaoa.set_depth">
<span class="sig-name descname"><span class="pre">set_depth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">depth</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qaoa.set_depth" title="Link to this definition"></a></dt>
<dd><p>Set the simulated <a class="reference internal" href="glossary.html#term-ansatz-depth"><span class="xref std std-term">ansatz depth</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>depth</strong><span class="classifier">int</span></dt><dd><p>number of ansatz iterations</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qaoa.set_initial_state">
<span class="sig-name descname"><span class="pre">set_initial_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_state_dict</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qaoa.set_initial_state" title="Link to this definition"></a></dt>
<dd><p>Define the <a class="reference internal" href="glossary.html#term-initial-state"><span class="xref std std-term">initial state</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>function</strong><span class="classifier">callable</span></dt><dd><p><a class="reference internal" href="quop_functions.html#term-Initial-State-Function"><span class="xref std std-term">Initial State Function</span></a></p>
</dd>
<dt><strong>initial_state_dict</strong><span class="classifier">FunctionDict, optional</span></dt><dd><p><a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> for the Initial State Function</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qaoa.set_log">
<span class="sig-name descname"><span class="pre">set_log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">action</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'a'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qaoa.set_log" title="Link to this definition"></a></dt>
<dd><p>Creates a CSV in which to save simulation results after a call to
<a class="reference internal" href="#quop_mpi.Ansatz.execute" title="quop_mpi.Ansatz.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>path to the log file</p>
</dd>
<dt><strong>label</strong><span class="classifier">str</span></dt><dd><p>simulation identifier</p>
</dd>
<dt><strong>action</strong><span class="classifier">{‘a’, ‘w’}, optional</span></dt><dd><p>‘a’ to append or ‘w’ overwrite, by default ‘a’</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qaoa.set_objective">
<span class="sig-name descname"><span class="pre">set_objective</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">objective_dict</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qaoa.set_objective" title="Link to this definition"></a></dt>
<dd><p>Set a custom objective function (i.e. an objective function other
than the expectation value of the prepared state).</p>
<p>The function is called after state evolution - returning a scalar
value that is passed to the minimizer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>function: callable</strong></dt><dd><p>an <a class="reference internal" href="quop_functions.html#term-Objective-Function"><span class="xref std std-term">Objective Function</span></a></p>
</dd>
<dt><strong>objective_dict: FunctionDict, optional</strong></dt><dd><p><a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> for the <cite>Objective Function</cite></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qaoa.set_observables">
<span class="sig-name descname"><span class="pre">set_observables</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">observable_dict</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qaoa.set_observables" title="Link to this definition"></a></dt>
<dd><p>Specify the <a class="reference internal" href="glossary.html#term-observables"><span class="xref std std-term">observables</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>function</strong><span class="classifier">callable or int</span></dt><dd><p>an <a class="reference internal" href="quop_functions.html#term-Observables-Function"><span class="xref std std-term">Observables Function</span></a> or an integer specifying the index
of a phase-shift unitary in the list passed to the
<a class="reference internal" href="#quop_mpi.Ansatz.set_observables" title="quop_mpi.Ansatz.set_observables"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_observables()</span></code></a> whose exponent contains the
observable vector.</p>
</dd>
<dt><strong>observables_dict: FunctionDict, optional</strong></dt><dd><p><a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> for the Observables Function</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qaoa.set_optimiser">
<span class="sig-name descname"><span class="pre">set_optimiser</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">optimiser</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimiser_args</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimiser_log</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qaoa.set_optimiser" title="Link to this definition"></a></dt>
<dd><p>Define the classical <a class="reference internal" href="glossary.html#term-optimiser"><span class="xref std std-term">optimiser</span></a> for <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVA</span></a> simulation.</p>
<p>Optionally allows for specification of arguments passed to the optimiser
and fields in the optimiser dictionary to write to the log file (see
<a class="reference internal" href="#quop_mpi.Ansatz.set_log" title="quop_mpi.Ansatz.set_log"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_log()</span></code></a>). QuOp_MPI supports optimisers provided by SciPy
through its minimize method <a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html">minimize</a>
and optimisers provided by the <a class="reference external" href="http://nlopt.readthedocs.io/en/latest/">NLopt</a> package with respect to
minimisation with scalar constraints through a SciPy-like interface.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>optimiser: {‘scipy’, ‘nlopt’}</strong></dt><dd><p>‘scipy’ to use the SciPy, ‘nlopt’ to use NLopt, or a callable
QuOp_MPI-compatible optimisation function.</p>
</dd>
<dt><strong>optimiser_args: dict</strong></dt><dd><p>arguments to pass to the optimiser</p>
</dd>
<dt><strong>optimiser_log: list[str]</strong></dt><dd><p>results of the optimisation process are stored in a dictionary.
These values may be logged by passing a list of the corresponding
keys</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>The default optimiser is the BFGS algorithm, which is set internally as
follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Ansatz</span><span class="o">.</span><span class="n">set_optimiser</span><span class="p">(</span> <span class="s1">&#39;scipy&#39;</span><span class="p">,</span>
        <span class="p">{</span><span class="s1">&#39;method&#39;</span><span class="p">:</span><span class="s1">&#39;BFGS&#39;</span><span class="p">,</span><span class="s1">&#39;options&#39;</span><span class="p">:{</span><span class="s1">&#39;gtol&#39;</span><span class="p">:</span><span class="mf">1e-3</span><span class="p">}},</span>
                    <span class="p">[</span><span class="s1">&#39;fun&#39;</span><span class="p">,</span><span class="s1">&#39;nfev&#39;</span><span class="p">,</span><span class="s1">&#39;success&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qaoa.set_parallel_jacobian">
<span class="sig-name descname"><span class="pre">set_parallel_jacobian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes_per_subcomm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">processes_per_node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxcomm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Callable</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'forward'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qaoa.set_parallel_jacobian" title="Link to this definition"></a></dt>
<dd><p>Specify <a class="reference internal" href="glossary.html#term-optimiser"><span class="xref std std-term">optimisation</span></a> of the <a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational
parameters</span></a> using parallel computation of the jacobian.</p>
<p>This creates MPI subcommunicators containing duplicates of the
<a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ansatz</span></code></a> instance which return partial derivative information to
the root MPI process during optimisation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nodes_per_subcomm</strong><span class="classifier">int</span></dt><dd><p>MPI nodes per subcommunicator</p>
</dd>
<dt><strong>processes_per_node</strong><span class="classifier">int</span></dt><dd><p>MPI processors associated with each node</p>
</dd>
<dt><strong>maxcomm</strong><span class="classifier">int</span></dt><dd><p>maximum number of created MPI subcommunicators (and <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ansatz</span></code></a>
instance duplicates) if <cite>nodes_per_subcomm &gt; 1</cite>, or the maximum
number of MPI subcommunicators per node if <cite>nodes_per_subcomm = 1</cite></p>
</dd>
<dt><strong>method :{‘forward’, ‘central’} or callable, optional</strong></dt><dd><p>‘forward’ or ‘central’ to used the forward difference or central
difference method for numerical approximation of the partial
derivatives, or a QuOp Jacobian Function, by default ‘forward’</p>
</dd>
<dt><strong>h</strong><span class="classifier">float, optional</span></dt><dd><p>step-size used by the forward or central difference methods, by
default <code class="docutils literal notranslate"><span class="pre">np.sqrt(np.finfo(float).eps)</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qaoa.set_parameter_map">
<span class="sig-name descname"><span class="pre">set_parameter_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mapping_fn</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">np.ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">np.ndarray</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mapping_dict</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qaoa.set_parameter_map" title="Link to this definition"></a></dt>
<dd><p>Register a mapping from a subset of optimisable parameters to the full
set of variational parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mapping_fn</strong><span class="classifier">callable</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">mapping_fn(free_vec,</span> <span class="pre">*args,</span> <span class="pre">**kwargs)</span> <span class="pre">-&gt;</span> <span class="pre">full_vec</span></code>.
<em>free_vec</em> is the vector presented to the optimiser;
<em>full_vec</em> must have length <code class="docutils literal notranslate"><span class="pre">ansatz_depth</span> <span class="pre">*</span> <span class="pre">total_params</span></code>.</p>
</dd>
<dt><strong>mapping_dict</strong><span class="classifier">FunctionDict, optional</span></dt><dd><p>FunctionDict supplying extra positional and keyword arguments
to the mapping function.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qaoa.set_params">
<span class="sig-name descname"><span class="pre">set_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">param_function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param_dict</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qaoa.set_params" title="Link to this definition"></a></dt>
<dd><p>Define the <a class="reference internal" href="quop_functions.html#term-Parameter-Function"><span class="xref std std-term">Parameter Function</span></a> for the 
<a class="reference internal" href="glossary.html#term-Phase-Shift-Unitary"><span class="xref std std-term">phase-shift</span></a> and 
<a class="reference internal" href="glossary.html#term-Mixing-Unitary"><span class="xref std std-term">mixing</span></a> unitaries.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>param_function</strong><span class="classifier">Callable</span></dt><dd><p>a <a class="reference internal" href="quop_functions.html#term-Parameter-Function"><span class="xref std std-term">Parameter Function</span></a></p>
</dd>
<dt><strong>param_dict</strong><span class="classifier">FunctionDict</span></dt><dd><p><a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> for <code class="docutils literal notranslate"><span class="pre">param_function</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qaoa.set_qualities">
<span class="sig-name descname"><span class="pre">set_qualities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">observables_dict</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qaoa.set_qualities" title="Link to this definition"></a></dt>
<dd><p>Define the <a class="reference internal" href="glossary.html#term-observables"><span class="xref std std-term">observables</span></a> and <a class="reference internal" href="glossary.html#term-Phase-Shift-Unitary"><span class="xref std std-term">phase-shift unitary</span></a> <a class="reference internal" href="glossary.html#term-operator"><span class="xref std std-term">operator</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>function</strong><span class="classifier">Callable</span></dt><dd><p>an <a class="reference internal" href="quop_functions.html#term-Operator-Function"><span class="xref std std-term">Operator Function</span></a></p>
</dd>
<dt><strong>observables_dict</strong><span class="classifier">FunctionDict, optional</span></dt><dd><p><a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> for <code class="docutils literal notranslate"><span class="pre">function</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qaoa.set_sampling">
<span class="sig-name descname"><span class="pre">set_sampling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample_block_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_sample_iterations</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_dict</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qaoa.set_sampling" title="Link to this definition"></a></dt>
<dd><p>Compute the <a class="reference internal" href="glossary.html#term-objective-function"><span class="xref std std-term">objective function</span></a> using simulated sampling.</p>
<p>Samples are taken in blocks of <cite>sample_block_size</cite>. These are passed as
a list of lists to <code class="docutils literal notranslate"><span class="pre">function</span></code> (a <a class="reference internal" href="quop_functions.html#term-Sampling-Function"><span class="xref std std-term">Sampling Function</span></a>), which returns a value for expectation
value/objective function and a boolean that indicates wether the sampled
result should be passed to the classical optimiser.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">function</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, the <a class="reference internal" href="glossary.html#term-objective-function"><span class="xref std std-term">objective function</span></a> is
computed as the mean of <code class="docutils literal notranslate"><span class="pre">sample_block_size</span></code> shots.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sample_block_size</strong><span class="classifier">int</span></dt><dd><p>number of shots taken between successive computation of the
expectation value/objective function</p>
</dd>
<dt><strong>function</strong><span class="classifier">callable, optional</span></dt><dd><p><a class="reference internal" href="quop_functions.html#term-Sampling-Function"><span class="xref std std-term">Sampling Function</span></a></p>
</dd>
<dt><strong>max_sample_iterations</strong><span class="classifier">int, optional</span></dt><dd><p>maximum number of sample blocks per computation of the expectation
value/objective function,  overrides the boolean returned by
<code class="docutils literal notranslate"><span class="pre">function</span></code>, by default 100</p>
</dd>
<dt><strong>sampling_dict</strong><span class="classifier">FunctionDict, optional</span></dt><dd><p><a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> for the Sampling Function</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qaoa.set_seed">
<span class="sig-name descname"><span class="pre">set_seed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qaoa.set_seed" title="Link to this definition"></a></dt>
<dd><p>Integer for seeding of random number generation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>seed</strong><span class="classifier">int</span></dt><dd><p>seeds the generation of random parameters</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qaoa.set_unitaries">
<span class="sig-name descname"><span class="pre">set_unitaries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unitaries</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#quop_mpi.Unitary" title="quop_mpi.Unitary.Unitary"><span class="pre">Unitary</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qaoa.set_unitaries" title="Link to this definition"></a></dt>
<dd><p>Define the <a class="reference internal" href="glossary.html#term-ansatz-unitary"><span class="xref std std-term">ansatz unitary</span></a>.</p>
<blockquote>
<div><p><a class="reference internal" href="glossary.html#term-unitary"><span class="xref std std-term">Unitaries</span></a> are passed as a python list in order of
application from left to right.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>unitaries: list[unitary]</strong></dt><dd><p>list of <a class="reference internal" href="glossary.html#term-unitary"><span class="xref std std-term">unitaries</span></a> specifying the action of one
<a class="reference internal" href="glossary.html#term-ansatz-depth"><span class="xref std std-term">ansatz iteration</span></a></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qaoa.unset_sampling">
<span class="sig-name descname"><span class="pre">unset_sampling</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qaoa.unset_sampling" title="Link to this definition"></a></dt>
<dd><p>Revert to simulation using exact computation of the
<a class="reference internal" href="glossary.html#term-objective-function"><span class="xref std std-term">objective function</span></a>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qwoa">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quop_mpi.algorithm.combinatorial.</span></span><span class="sig-name descname"><span class="pre">qwoa</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">MPI_communicator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpi4py.MPI.Intracomm</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">mpi4py.MPI.COMM_WORLD</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qwoa" title="Link to this definition"></a></dt>
<dd><p>Simulate the <a class="reference internal" href="theoretical_background.html#qwoa"><span class="std std-ref">QWOA</span></a>.</p>
<p>See <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>system_size</strong><span class="classifier">int</span></dt><dd><p><a class="reference internal" href="glossary.html#term-system-size"><span class="xref std std-term">system size</span></a> of the simulated <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVA</span></a></p>
</dd>
<dt><strong>MPI_COMM</strong><span class="classifier">Intracomm, optional</span></dt><dd><p>MPI communicator, default <code class="docutils literal notranslate"><span class="pre">mpi4py.MPI.COMM_WORLD</span></code></p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qwoa.benchmark">
<span class="sig-name descname"><span class="pre">benchmark</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ansatz_depths</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repeats</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_parameters</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param_persist</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'test'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_action</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'a'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_limit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suspend_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qwoa.benchmark" title="Link to this definition"></a></dt>
<dd><p>A method by which to study how a QVA performs as the number
of ansatz iterations&lt;ansatz depth&gt; increases.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ansatz_depths</strong><span class="classifier">iterable[int]</span></dt><dd><p>integers specifying a sequence of ansatz depths&lt;ansatz depth&gt;</p>
</dd>
<dt><strong>repeats</strong><span class="classifier">int</span></dt><dd><p>number of repeats at each ansatz depth</p>
</dd>
<dt><strong>initial_parameters: list[float] or ndarray[float], optional</strong></dt><dd><p>** Must be defined if a parameter mapping function is set. **
initial variational parameter values, if not present these are generated
using the default parameter generation methods of the ansatz unitaries.</p>
</dd>
<dt><strong>param_persist</strong><span class="classifier">bool, optional</span></dt><dd><p>if True the optimised variational parameter values which achieved
the lowest objective function value for all repeats at ansatz_depth
will be used as starting parameters for the first
ansatz_depth * total_params at ansatz_depth += 1. if a parameter
map is set, the initial parameters will update whenever the 
objective function reaches a new minimum.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool, optional</span></dt><dd><p>if True, print current the ansatz depth, repeat number and
optimisation results (default True)</p>
</dd>
<dt><strong>filename</strong><span class="classifier">str or None, optional</span></dt><dd><p>name of <a href="#id12"><span class="problematic" id="id13">*</span></a>.h5 file in which to save the optimised system state and observables</p>
</dd>
<dt><strong>label</strong><span class="classifier">str, optional</span></dt><dd><p>if filename is not None, <a href="#id14"><span class="problematic" id="id15">*</span></a>.h5 data will be saved as
“filename/label_depth_repeat” (default “test”)</p>
</dd>
<dt><strong>save_action</strong><span class="classifier">{‘a’, ‘w’}, optional</span></dt><dd><p>action taken during first file write: ‘a’ to append, ‘w’ to overwrite (default ‘a’)</p>
</dd>
<dt><strong>time_limit</strong><span class="classifier">int or None, optional</span></dt><dd><p>total allocated in-program time in seconds; if exceeded, the benchmark is suspended</p>
</dd>
<dt><strong>suspend_path</strong><span class="classifier">str or None, optional</span></dt><dd><p>path to the suspend file if time_limit is not None</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qwoa.evaluate">
<span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variational_parameters</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qwoa.evaluate" title="Link to this definition"></a></dt>
<dd><p>Lazily computes the <a class="reference internal" href="glossary.html#term-objective-function"><span class="xref std std-term">objective function</span></a> value.</p>
<p>The <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ansatz</span></code></a> instance stores the last <a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational
parameters</span></a> passed to <code class="docutils literal notranslate"><span class="pre">evaluate</span></code> and the corresponding objective
function value. If the input variational parameters match,
re-computation of the <a class="reference internal" href="glossary.html#term-final-state"><span class="xref std std-term">final state</span></a> is skipped and the previously
computed objective function value is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>variational_parameters</strong><span class="classifier">list[float] or ndarray[float]</span></dt><dd><p>1-D <code class="docutils literal notranslate"><span class="pre">(ansatz_depth</span> <span class="pre">*</span> <span class="pre">total_params,)</span></code> real array of variational
parameters</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>float</dt><dd><p>objective function value</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qwoa.evolve_state">
<span class="sig-name descname"><span class="pre">evolve_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variational_parameters</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qwoa.evolve_state" title="Link to this definition"></a></dt>
<dd><p>Compute the <a class="reference internal" href="glossary.html#term-system-state"><span class="xref std std-term">system state</span></a> under the action of the
<a class="reference internal" href="glossary.html#term-ansatz-unitary"><span class="xref std std-term">ansatz unitary</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>variational_parameters</strong><span class="classifier">list[float] or ndarray[float]</span></dt><dd><p>1-D <code class="docutils literal notranslate"><span class="pre">(ansatz_depth</span> <span class="pre">*</span> <span class="pre">total_params,)</span></code> real array of
<a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational parameters</span></a>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#quop_mpi.Ansatz.set_unitaries" title="quop_mpi.Ansatz.set_unitaries"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_unitaries()</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qwoa.execute">
<span class="sig-name descname"><span class="pre">execute</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variational_parameters</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qwoa.execute" title="Link to this definition"></a></dt>
<dd><p>Simulate a <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVA</span></a>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">variational_parameters</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, initial parameter values are
generated using the <a class="reference internal" href="quop_functions.html#term-Parameter-Function"><span class="xref std std-term">Parameter Function</span></a> of the corresponding
<code class="docutils literal notranslate"><span class="pre">unitary</span></code> instances.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>variational_parameters</strong><span class="classifier">list[float] or ndarray[float]</span></dt><dd><p>1-D <code class="docutils literal notranslate"><span class="pre">(ansatz_depth</span> <span class="pre">*</span> <span class="pre">total_params,)</span></code> real array of
<a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational parameters</span></a></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qwoa.gen_initial_params">
<span class="sig-name descname"><span class="pre">gen_initial_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ansatz_depth</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qwoa.gen_initial_params" title="Link to this definition"></a></dt>
<dd><p>Generate initial <a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational parameters</span></a>.</p>
<p>Values are generated using the <a class="reference internal" href="quop_functions.html#term-Parameter-Function"><span class="xref std std-term">Parameter Function</span></a> associated
with each <code class="docutils literal notranslate"><span class="pre">unitary</span></code> passed to the <a class="reference internal" href="#quop_mpi.Ansatz.set_unitaries" title="quop_mpi.Ansatz.set_unitaries"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_unitaries()</span></code></a>
method.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="docutils literal notranslate"><span class="pre">ansatz_depth</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code> the <a class="reference internal" href="glossary.html#term-ansatz-depth"><span class="xref std std-term">ansatz depth</span></a> defaults 
to <cite>1</cite> or the depth specified by the <a class="reference internal" href="#quop_mpi.Ansatz.set_depth" title="quop_mpi.Ansatz.set_depth"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_depth()</span></code></a> method.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ansatz_depth</strong><span class="classifier">int, optional</span></dt><dd><p>number of <a class="reference internal" href="glossary.html#term-ansatz-depth"><span class="xref std std-term">ansatz iterations</span></a></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray[float64]</dt><dd><p>1-D <code class="docutils literal notranslate"><span class="pre">(ansatz_depth</span> <span class="pre">*</span> <span class="pre">total_params,)</span></code> real array of variational
parameters</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qwoa.get_expectation_value">
<span class="sig-name descname"><span class="pre">get_expectation_value</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qwoa.get_expectation_value" title="Link to this definition"></a></dt>
<dd><p>Compute the <a class="reference internal" href="glossary.html#term-objective-function"><span class="xref std std-term">objective function</span></a> at the current
value of <code class="xref py py-meth docutils literal notranslate"><span class="pre">variational_parameters()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>float</dt><dd><p>objective function value</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qwoa.get_final_state">
<span class="sig-name descname"><span class="pre">get_final_state</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.complex128</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qwoa.get_final_state" title="Link to this definition"></a></dt>
<dd><p>Gather the <a class="reference internal" href="glossary.html#term-final-state"><span class="xref std std-term">final state</span></a> to rank 0 of the <code class="docutils literal notranslate"><span class="pre">Ansatz</span></code> MPI subcommunicator.</p>
<p>Requires a previous call to <a class="reference internal" href="#quop_mpi.Ansatz.execute" title="quop_mpi.Ansatz.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code></a>, <a class="reference internal" href="#quop_mpi.Ansatz.evolve_state" title="quop_mpi.Ansatz.evolve_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">evolve_state()</span></code></a>
or <a class="reference internal" href="#quop_mpi.Ansatz.benchmark" title="quop_mpi.Ansatz.benchmark"><code class="xref py py-meth docutils literal notranslate"><span class="pre">benchmark()</span></code></a>. If called after <a class="reference internal" href="#quop_mpi.Ansatz.benchmark" title="quop_mpi.Ansatz.benchmark"><code class="xref py py-meth docutils literal notranslate"><span class="pre">benchmark()</span></code></a> the
gathered state will correspond to the last performed simulation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>ndarray[complex128] or None</dt><dd><p>the final state at rank 0 of the <code class="docutils literal notranslate"><span class="pre">Ansatz</span></code> subcommunicator, <code class="docutils literal notranslate"><span class="pre">None</span></code> otherwise</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qwoa.get_probabilities">
<span class="sig-name descname"><span class="pre">get_probabilities</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.float64</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qwoa.get_probabilities" title="Link to this definition"></a></dt>
<dd><p>Gather probabilities computed from the <a class="reference internal" href="glossary.html#term-final-state"><span class="xref std std-term">final state</span></a> at rank 0
of the <code class="docutils literal notranslate"><span class="pre">Ansatz</span></code> MPI subcommunicator.</p>
<p>Requires a previous call to <a class="reference internal" href="#quop_mpi.Ansatz.execute" title="quop_mpi.Ansatz.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code></a>,
<a class="reference internal" href="#quop_mpi.Ansatz.evolve_state" title="quop_mpi.Ansatz.evolve_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">evolve_state()</span></code></a> or <a class="reference internal" href="#quop_mpi.Ansatz.benchmark" title="quop_mpi.Ansatz.benchmark"><code class="xref py py-meth docutils literal notranslate"><span class="pre">benchmark()</span></code></a>. If called after
<a class="reference internal" href="#quop_mpi.Ansatz.benchmark" title="quop_mpi.Ansatz.benchmark"><code class="xref py py-meth docutils literal notranslate"><span class="pre">benchmark()</span></code></a> the gathered state will correspond to the last
performed simulation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>ndarray[float64] or None</dt><dd><p>1-D real array of state probabilities at rank 0 of the <code class="docutils literal notranslate"><span class="pre">Ansatz</span></code>
subcommunicator, <code class="docutils literal notranslate"><span class="pre">None</span></code> otherwise</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qwoa.objective">
<span class="sig-name descname"><span class="pre">objective</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variational_parameters</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qwoa.objective" title="Link to this definition"></a></dt>
<dd><p>Compute the <a class="reference internal" href="glossary.html#term-objective-function"><span class="xref std std-term">objective function</span></a> at <a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational parameters</span></a> 
<code class="docutils literal notranslate"><span class="pre">variational_parameters</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>variational_parameters</strong><span class="classifier">list or ndarray[float]</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>float</dt><dd><p>objective function value</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qwoa.print_optimiser_result">
<span class="sig-name descname"><span class="pre">print_optimiser_result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qwoa.print_optimiser_result" title="Link to this definition"></a></dt>
<dd><p>Print the result returned from the <a class="reference internal" href="glossary.html#term-optimiser"><span class="xref std std-term">optimiser</span></a> for the last
<a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVA</span></a> simulation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qwoa.print_result">
<span class="sig-name descname"><span class="pre">print_result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qwoa.print_result" title="Link to this definition"></a></dt>
<dd><p>Print a summary of the results of the last <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVA</span></a> simulation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qwoa.save">
<span class="sig-name descname"><span class="pre">save</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">config_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">action</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'a'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qwoa.save" title="Link to this definition"></a></dt>
<dd><p>Write the <a class="reference internal" href="glossary.html#term-final-state"><span class="xref std std-term">final state</span></a>, <a class="reference internal" href="glossary.html#term-observables"><span class="xref std std-term">observables</span></a> and results
summary to a HDf5 file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>file_name</strong><span class="classifier">str</span></dt><dd><p>file path to saved data</p>
</dd>
<dt><strong>config_name</strong><span class="classifier">str</span></dt><dd><p>simulation identifier</p>
</dd>
<dt><strong>action</strong><span class="classifier">{‘a’, ‘w’}, optional</span></dt><dd><p>‘a’ to append or ‘w’ to overwrite, by default ‘a’</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Data is saved into a <code class="docutils literal notranslate"><span class="pre">*.h5</span></code> file with the following structure.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>├── config_name
    ├── final_state 
    ├── observables
</pre></div>
</div>
<p>The minimization result is saved in the ‘minimize_result’ attribute of
‘config_name’ as a formatted string.</p>
<p>Multiple configurations with a unique config_name can be stored in the
same .h5 file. HDF5 files are supported in python by the <a class="reference external" href="https://www.h5py.org/">h5py</a> package. With it, a saved configuration can be
accessed as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">h5py</span>

<span class="n">config_name</span> <span class="o">=</span> <span class="s2">&quot;my_simulation&quot;</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">file_name</span> <span class="o">+</span> <span class="s2">&quot;.h5&quot;</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="n">final_state</span> <span class="o">=</span>
<span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">config_name</span><span class="p">][</span><span class="s1">&#39;final_state&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
<span class="n">eigenvalues</span> <span class="o">=</span>
<span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">config_name</span><span class="p">][</span><span class="s1">&#39;eigenvalues&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
<span class="n">observables</span> <span class="o">=</span>
<span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">config_name</span><span class="p">][</span><span class="s1">&#39;observables&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s2">&quot;my_simulation&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;minimize_result&quot;</span><span class="p">])</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The <code class="docutils literal notranslate"><span class="pre">&quot;final_state&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;observables&quot;</span></code> datasets are saved using Fortran
subroutines which make use of parallel HDF5.</p>
<p>The complex values of the final_state array are saved as a compound
datatype consisting of contiguous double precision reals. This is
equivalent to the np.complex128 NumPy datatype. To access this data
without a loss of precision in python, the user must set the
<strong>view</strong> of the NumPy array to np.complex128, rather than casting it
to np.complex128 using the dtype keyword.</p>
<p>Similarly, the observables array, which is saved as an array of
double-precision reals, should have its view set to np.float64.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qwoa.set_depth">
<span class="sig-name descname"><span class="pre">set_depth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">depth</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qwoa.set_depth" title="Link to this definition"></a></dt>
<dd><p>Set the simulated <a class="reference internal" href="glossary.html#term-ansatz-depth"><span class="xref std std-term">ansatz depth</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>depth</strong><span class="classifier">int</span></dt><dd><p>number of ansatz iterations</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qwoa.set_initial_state">
<span class="sig-name descname"><span class="pre">set_initial_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_state_dict</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qwoa.set_initial_state" title="Link to this definition"></a></dt>
<dd><p>Define the <a class="reference internal" href="glossary.html#term-initial-state"><span class="xref std std-term">initial state</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>function</strong><span class="classifier">callable</span></dt><dd><p><a class="reference internal" href="quop_functions.html#term-Initial-State-Function"><span class="xref std std-term">Initial State Function</span></a></p>
</dd>
<dt><strong>initial_state_dict</strong><span class="classifier">FunctionDict, optional</span></dt><dd><p><a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> for the Initial State Function</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qwoa.set_log">
<span class="sig-name descname"><span class="pre">set_log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">action</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'a'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qwoa.set_log" title="Link to this definition"></a></dt>
<dd><p>Creates a CSV in which to save simulation results after a call to
<a class="reference internal" href="#quop_mpi.Ansatz.execute" title="quop_mpi.Ansatz.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>path to the log file</p>
</dd>
<dt><strong>label</strong><span class="classifier">str</span></dt><dd><p>simulation identifier</p>
</dd>
<dt><strong>action</strong><span class="classifier">{‘a’, ‘w’}, optional</span></dt><dd><p>‘a’ to append or ‘w’ overwrite, by default ‘a’</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qwoa.set_objective">
<span class="sig-name descname"><span class="pre">set_objective</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">objective_dict</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qwoa.set_objective" title="Link to this definition"></a></dt>
<dd><p>Set a custom objective function (i.e. an objective function other
than the expectation value of the prepared state).</p>
<p>The function is called after state evolution - returning a scalar
value that is passed to the minimizer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>function: callable</strong></dt><dd><p>an <a class="reference internal" href="quop_functions.html#term-Objective-Function"><span class="xref std std-term">Objective Function</span></a></p>
</dd>
<dt><strong>objective_dict: FunctionDict, optional</strong></dt><dd><p><a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> for the <cite>Objective Function</cite></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qwoa.set_observables">
<span class="sig-name descname"><span class="pre">set_observables</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">observable_dict</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qwoa.set_observables" title="Link to this definition"></a></dt>
<dd><p>Specify the <a class="reference internal" href="glossary.html#term-observables"><span class="xref std std-term">observables</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>function</strong><span class="classifier">callable or int</span></dt><dd><p>an <a class="reference internal" href="quop_functions.html#term-Observables-Function"><span class="xref std std-term">Observables Function</span></a> or an integer specifying the index
of a phase-shift unitary in the list passed to the
<a class="reference internal" href="#quop_mpi.Ansatz.set_observables" title="quop_mpi.Ansatz.set_observables"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_observables()</span></code></a> whose exponent contains the
observable vector.</p>
</dd>
<dt><strong>observables_dict: FunctionDict, optional</strong></dt><dd><p><a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> for the Observables Function</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qwoa.set_optimiser">
<span class="sig-name descname"><span class="pre">set_optimiser</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">optimiser</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimiser_args</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimiser_log</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qwoa.set_optimiser" title="Link to this definition"></a></dt>
<dd><p>Define the classical <a class="reference internal" href="glossary.html#term-optimiser"><span class="xref std std-term">optimiser</span></a> for <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVA</span></a> simulation.</p>
<p>Optionally allows for specification of arguments passed to the optimiser
and fields in the optimiser dictionary to write to the log file (see
<a class="reference internal" href="#quop_mpi.Ansatz.set_log" title="quop_mpi.Ansatz.set_log"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_log()</span></code></a>). QuOp_MPI supports optimisers provided by SciPy
through its minimize method <a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html">minimize</a>
and optimisers provided by the <a class="reference external" href="http://nlopt.readthedocs.io/en/latest/">NLopt</a> package with respect to
minimisation with scalar constraints through a SciPy-like interface.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>optimiser: {‘scipy’, ‘nlopt’}</strong></dt><dd><p>‘scipy’ to use the SciPy, ‘nlopt’ to use NLopt, or a callable
QuOp_MPI-compatible optimisation function.</p>
</dd>
<dt><strong>optimiser_args: dict</strong></dt><dd><p>arguments to pass to the optimiser</p>
</dd>
<dt><strong>optimiser_log: list[str]</strong></dt><dd><p>results of the optimisation process are stored in a dictionary.
These values may be logged by passing a list of the corresponding
keys</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>The default optimiser is the BFGS algorithm, which is set internally as
follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Ansatz</span><span class="o">.</span><span class="n">set_optimiser</span><span class="p">(</span> <span class="s1">&#39;scipy&#39;</span><span class="p">,</span>
        <span class="p">{</span><span class="s1">&#39;method&#39;</span><span class="p">:</span><span class="s1">&#39;BFGS&#39;</span><span class="p">,</span><span class="s1">&#39;options&#39;</span><span class="p">:{</span><span class="s1">&#39;gtol&#39;</span><span class="p">:</span><span class="mf">1e-3</span><span class="p">}},</span>
                    <span class="p">[</span><span class="s1">&#39;fun&#39;</span><span class="p">,</span><span class="s1">&#39;nfev&#39;</span><span class="p">,</span><span class="s1">&#39;success&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qwoa.set_parallel_jacobian">
<span class="sig-name descname"><span class="pre">set_parallel_jacobian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes_per_subcomm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">processes_per_node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxcomm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Callable</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'forward'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qwoa.set_parallel_jacobian" title="Link to this definition"></a></dt>
<dd><p>Specify <a class="reference internal" href="glossary.html#term-optimiser"><span class="xref std std-term">optimisation</span></a> of the <a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational
parameters</span></a> using parallel computation of the jacobian.</p>
<p>This creates MPI subcommunicators containing duplicates of the
<a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ansatz</span></code></a> instance which return partial derivative information to
the root MPI process during optimisation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nodes_per_subcomm</strong><span class="classifier">int</span></dt><dd><p>MPI nodes per subcommunicator</p>
</dd>
<dt><strong>processes_per_node</strong><span class="classifier">int</span></dt><dd><p>MPI processors associated with each node</p>
</dd>
<dt><strong>maxcomm</strong><span class="classifier">int</span></dt><dd><p>maximum number of created MPI subcommunicators (and <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ansatz</span></code></a>
instance duplicates) if <cite>nodes_per_subcomm &gt; 1</cite>, or the maximum
number of MPI subcommunicators per node if <cite>nodes_per_subcomm = 1</cite></p>
</dd>
<dt><strong>method :{‘forward’, ‘central’} or callable, optional</strong></dt><dd><p>‘forward’ or ‘central’ to used the forward difference or central
difference method for numerical approximation of the partial
derivatives, or a QuOp Jacobian Function, by default ‘forward’</p>
</dd>
<dt><strong>h</strong><span class="classifier">float, optional</span></dt><dd><p>step-size used by the forward or central difference methods, by
default <code class="docutils literal notranslate"><span class="pre">np.sqrt(np.finfo(float).eps)</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qwoa.set_parameter_map">
<span class="sig-name descname"><span class="pre">set_parameter_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mapping_fn</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">np.ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">np.ndarray</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mapping_dict</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qwoa.set_parameter_map" title="Link to this definition"></a></dt>
<dd><p>Register a mapping from a subset of optimisable parameters to the full
set of variational parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mapping_fn</strong><span class="classifier">callable</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">mapping_fn(free_vec,</span> <span class="pre">*args,</span> <span class="pre">**kwargs)</span> <span class="pre">-&gt;</span> <span class="pre">full_vec</span></code>.
<em>free_vec</em> is the vector presented to the optimiser;
<em>full_vec</em> must have length <code class="docutils literal notranslate"><span class="pre">ansatz_depth</span> <span class="pre">*</span> <span class="pre">total_params</span></code>.</p>
</dd>
<dt><strong>mapping_dict</strong><span class="classifier">FunctionDict, optional</span></dt><dd><p>FunctionDict supplying extra positional and keyword arguments
to the mapping function.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qwoa.set_params">
<span class="sig-name descname"><span class="pre">set_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">param_function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qwoa.set_params" title="Link to this definition"></a></dt>
<dd><p>Define the <a class="reference internal" href="quop_functions.html#term-Parameter-Function"><span class="xref std std-term">Parameter Function</span></a> for the <a class="reference internal" href="glossary.html#term-Phase-Shift-Unitary"><span class="xref std std-term">phase-shift</span></a> and <a class="reference internal" href="glossary.html#term-Mixing-Unitary"><span class="xref std std-term">mixing</span></a> unitaries.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>param_function</strong><span class="classifier">Callable</span></dt><dd><p>a <a class="reference internal" href="quop_functions.html#term-Parameter-Function"><span class="xref std std-term">Parameter Function</span></a></p>
</dd>
<dt><strong>param_dict</strong><span class="classifier">FunctionDict</span></dt><dd><p><a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> for <code class="docutils literal notranslate"><span class="pre">param_function</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qwoa.set_qualities">
<span class="sig-name descname"><span class="pre">set_qualities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">observable_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qwoa.set_qualities" title="Link to this definition"></a></dt>
<dd><p>Define the <a class="reference internal" href="glossary.html#term-observables"><span class="xref std std-term">observables</span></a> and <a class="reference internal" href="glossary.html#term-Phase-Shift-Unitary"><span class="xref std std-term">phase-shift unitary</span></a> <a class="reference internal" href="glossary.html#term-operator"><span class="xref std std-term">operator</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>function</strong><span class="classifier">Callable</span></dt><dd><p>an <a class="reference internal" href="quop_functions.html#term-Operator-Function"><span class="xref std std-term">Operator Function</span></a></p>
</dd>
<dt><strong>observable_dict</strong><span class="classifier">FunctionDict, optional</span></dt><dd><p><a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> for <code class="docutils literal notranslate"><span class="pre">function</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qwoa.set_sampling">
<span class="sig-name descname"><span class="pre">set_sampling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample_block_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_sample_iterations</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_dict</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qwoa.set_sampling" title="Link to this definition"></a></dt>
<dd><p>Compute the <a class="reference internal" href="glossary.html#term-objective-function"><span class="xref std std-term">objective function</span></a> using simulated sampling.</p>
<p>Samples are taken in blocks of <cite>sample_block_size</cite>. These are passed as
a list of lists to <code class="docutils literal notranslate"><span class="pre">function</span></code> (a <a class="reference internal" href="quop_functions.html#term-Sampling-Function"><span class="xref std std-term">Sampling Function</span></a>), which returns a value for expectation
value/objective function and a boolean that indicates wether the sampled
result should be passed to the classical optimiser.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">function</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, the <a class="reference internal" href="glossary.html#term-objective-function"><span class="xref std std-term">objective function</span></a> is
computed as the mean of <code class="docutils literal notranslate"><span class="pre">sample_block_size</span></code> shots.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sample_block_size</strong><span class="classifier">int</span></dt><dd><p>number of shots taken between successive computation of the
expectation value/objective function</p>
</dd>
<dt><strong>function</strong><span class="classifier">callable, optional</span></dt><dd><p><a class="reference internal" href="quop_functions.html#term-Sampling-Function"><span class="xref std std-term">Sampling Function</span></a></p>
</dd>
<dt><strong>max_sample_iterations</strong><span class="classifier">int, optional</span></dt><dd><p>maximum number of sample blocks per computation of the expectation
value/objective function,  overrides the boolean returned by
<code class="docutils literal notranslate"><span class="pre">function</span></code>, by default 100</p>
</dd>
<dt><strong>sampling_dict</strong><span class="classifier">FunctionDict, optional</span></dt><dd><p><a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> for the Sampling Function</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qwoa.set_seed">
<span class="sig-name descname"><span class="pre">set_seed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qwoa.set_seed" title="Link to this definition"></a></dt>
<dd><p>Integer for seeding of random number generation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>seed</strong><span class="classifier">int</span></dt><dd><p>seeds the generation of random parameters</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qwoa.set_unitaries">
<span class="sig-name descname"><span class="pre">set_unitaries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unitaries</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#quop_mpi.Unitary" title="quop_mpi.Unitary.Unitary"><span class="pre">Unitary</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qwoa.set_unitaries" title="Link to this definition"></a></dt>
<dd><p>Define the <a class="reference internal" href="glossary.html#term-ansatz-unitary"><span class="xref std std-term">ansatz unitary</span></a>.</p>
<blockquote>
<div><p><a class="reference internal" href="glossary.html#term-unitary"><span class="xref std std-term">Unitaries</span></a> are passed as a python list in order of
application from left to right.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>unitaries: list[unitary]</strong></dt><dd><p>list of <a class="reference internal" href="glossary.html#term-unitary"><span class="xref std std-term">unitaries</span></a> specifying the action of one
<a class="reference internal" href="glossary.html#term-ansatz-depth"><span class="xref std std-term">ansatz iteration</span></a></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.combinatorial.qwoa.unset_sampling">
<span class="sig-name descname"><span class="pre">unset_sampling</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.combinatorial.qwoa.unset_sampling" title="Link to this definition"></a></dt>
<dd><p>Revert to simulation using exact computation of the
<a class="reference internal" href="glossary.html#term-objective-function"><span class="xref std std-term">objective function</span></a>.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-quop_mpi.algorithm.multivariable">
<span id="multivariable"></span><h3>multivariable<a class="headerlink" href="#module-quop_mpi.algorithm.multivariable" title="Link to this heading"></a></h3>
<p>Predefined <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVAs</span></a> for the optimisation of continuous multivariable
functions.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The following compatible <a class="reference internal" href="quop_functions.html#term-Operator-Function"><span class="xref std std-term">Operator Functions</span></a> may
be imported from the <a class="reference internal" href="#module-quop_mpi.algorithm.multivariable" title="quop_mpi.algorithm.multivariable"><code class="xref py py-mod docutils literal notranslate"><span class="pre">multivariable</span></code></a> :</p>
<ul class="simple">
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">setup_cartesian()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">cartesian()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">cartesian_scaled()</span></code></p></li>
</ul>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qmoa">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quop_mpi.algorithm.multivariable.</span></span><span class="sig-name descname"><span class="pre">qmoa</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Ns</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">MPI_COMM</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpi4py.MPI.Intracomm</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">mpi4py.MPI.COMM_WORLD</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qmoa" title="Link to this definition"></a></dt>
<dd><p>Simulate the <a class="reference internal" href="theoretical_background.html#qmoa"><span class="std std-ref">QMOA</span></a>.</p>
<p>A <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVA</span></a> for the optimisation of continuous multivariable
functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Ns</strong><span class="classifier">list[int]</span></dt><dd><p>the number of grid points in each each coordinate dimension</p>
</dd>
<dt><strong>MPI_communicator</strong><span class="classifier">Intracomm, optional</span></dt><dd><p>MPI Intracomm, by default MPI.COMM_WORLD</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qmoa.benchmark">
<span class="sig-name descname"><span class="pre">benchmark</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ansatz_depths</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repeats</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_parameters</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param_persist</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'test'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_action</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'a'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_limit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suspend_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qmoa.benchmark" title="Link to this definition"></a></dt>
<dd><p>A method by which to study how a QVA performs as the number
of ansatz iterations&lt;ansatz depth&gt; increases.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ansatz_depths</strong><span class="classifier">iterable[int]</span></dt><dd><p>integers specifying a sequence of ansatz depths&lt;ansatz depth&gt;</p>
</dd>
<dt><strong>repeats</strong><span class="classifier">int</span></dt><dd><p>number of repeats at each ansatz depth</p>
</dd>
<dt><strong>initial_parameters: list[float] or ndarray[float], optional</strong></dt><dd><p>** Must be defined if a parameter mapping function is set. **
initial variational parameter values, if not present these are generated
using the default parameter generation methods of the ansatz unitaries.</p>
</dd>
<dt><strong>param_persist</strong><span class="classifier">bool, optional</span></dt><dd><p>if True the optimised variational parameter values which achieved
the lowest objective function value for all repeats at ansatz_depth
will be used as starting parameters for the first
ansatz_depth * total_params at ansatz_depth += 1. if a parameter
map is set, the initial parameters will update whenever the 
objective function reaches a new minimum.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool, optional</span></dt><dd><p>if True, print current the ansatz depth, repeat number and
optimisation results (default True)</p>
</dd>
<dt><strong>filename</strong><span class="classifier">str or None, optional</span></dt><dd><p>name of <a href="#id19"><span class="problematic" id="id20">*</span></a>.h5 file in which to save the optimised system state and observables</p>
</dd>
<dt><strong>label</strong><span class="classifier">str, optional</span></dt><dd><p>if filename is not None, <a href="#id21"><span class="problematic" id="id22">*</span></a>.h5 data will be saved as
“filename/label_depth_repeat” (default “test”)</p>
</dd>
<dt><strong>save_action</strong><span class="classifier">{‘a’, ‘w’}, optional</span></dt><dd><p>action taken during first file write: ‘a’ to append, ‘w’ to overwrite (default ‘a’)</p>
</dd>
<dt><strong>time_limit</strong><span class="classifier">int or None, optional</span></dt><dd><p>total allocated in-program time in seconds; if exceeded, the benchmark is suspended</p>
</dd>
<dt><strong>suspend_path</strong><span class="classifier">str or None, optional</span></dt><dd><p>path to the suspend file if time_limit is not None</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qmoa.evaluate">
<span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variational_parameters</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qmoa.evaluate" title="Link to this definition"></a></dt>
<dd><p>Lazily computes the <a class="reference internal" href="glossary.html#term-objective-function"><span class="xref std std-term">objective function</span></a> value.</p>
<p>The <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ansatz</span></code></a> instance stores the last <a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational
parameters</span></a> passed to <code class="docutils literal notranslate"><span class="pre">evaluate</span></code> and the corresponding objective
function value. If the input variational parameters match,
re-computation of the <a class="reference internal" href="glossary.html#term-final-state"><span class="xref std std-term">final state</span></a> is skipped and the previously
computed objective function value is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>variational_parameters</strong><span class="classifier">list[float] or ndarray[float]</span></dt><dd><p>1-D <code class="docutils literal notranslate"><span class="pre">(ansatz_depth</span> <span class="pre">*</span> <span class="pre">total_params,)</span></code> real array of variational
parameters</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>float</dt><dd><p>objective function value</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qmoa.evolve_state">
<span class="sig-name descname"><span class="pre">evolve_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variational_parameters</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qmoa.evolve_state" title="Link to this definition"></a></dt>
<dd><p>Compute the <a class="reference internal" href="glossary.html#term-system-state"><span class="xref std std-term">system state</span></a> under the action of the
<a class="reference internal" href="glossary.html#term-ansatz-unitary"><span class="xref std std-term">ansatz unitary</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>variational_parameters</strong><span class="classifier">list[float] or ndarray[float]</span></dt><dd><p>1-D <code class="docutils literal notranslate"><span class="pre">(ansatz_depth</span> <span class="pre">*</span> <span class="pre">total_params,)</span></code> real array of
<a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational parameters</span></a>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#quop_mpi.Ansatz.set_unitaries" title="quop_mpi.Ansatz.set_unitaries"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_unitaries()</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qmoa.execute">
<span class="sig-name descname"><span class="pre">execute</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variational_parameters</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qmoa.execute" title="Link to this definition"></a></dt>
<dd><p>Simulate a <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVA</span></a>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">variational_parameters</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, initial parameter values are
generated using the <a class="reference internal" href="quop_functions.html#term-Parameter-Function"><span class="xref std std-term">Parameter Function</span></a> of the corresponding
<code class="docutils literal notranslate"><span class="pre">unitary</span></code> instances.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>variational_parameters</strong><span class="classifier">list[float] or ndarray[float]</span></dt><dd><p>1-D <code class="docutils literal notranslate"><span class="pre">(ansatz_depth</span> <span class="pre">*</span> <span class="pre">total_params,)</span></code> real array of
<a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational parameters</span></a></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qmoa.gen_initial_params">
<span class="sig-name descname"><span class="pre">gen_initial_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ansatz_depth</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qmoa.gen_initial_params" title="Link to this definition"></a></dt>
<dd><p>Generate initial <a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational parameters</span></a>.</p>
<p>Values are generated using the <a class="reference internal" href="quop_functions.html#term-Parameter-Function"><span class="xref std std-term">Parameter Function</span></a> associated
with each <code class="docutils literal notranslate"><span class="pre">unitary</span></code> passed to the <a class="reference internal" href="#quop_mpi.Ansatz.set_unitaries" title="quop_mpi.Ansatz.set_unitaries"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_unitaries()</span></code></a>
method.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="docutils literal notranslate"><span class="pre">ansatz_depth</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code> the <a class="reference internal" href="glossary.html#term-ansatz-depth"><span class="xref std std-term">ansatz depth</span></a> defaults 
to <cite>1</cite> or the depth specified by the <a class="reference internal" href="#quop_mpi.Ansatz.set_depth" title="quop_mpi.Ansatz.set_depth"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_depth()</span></code></a> method.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ansatz_depth</strong><span class="classifier">int, optional</span></dt><dd><p>number of <a class="reference internal" href="glossary.html#term-ansatz-depth"><span class="xref std std-term">ansatz iterations</span></a></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray[float64]</dt><dd><p>1-D <code class="docutils literal notranslate"><span class="pre">(ansatz_depth</span> <span class="pre">*</span> <span class="pre">total_params,)</span></code> real array of variational
parameters</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qmoa.get_expectation_value">
<span class="sig-name descname"><span class="pre">get_expectation_value</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qmoa.get_expectation_value" title="Link to this definition"></a></dt>
<dd><p>Compute the <a class="reference internal" href="glossary.html#term-objective-function"><span class="xref std std-term">objective function</span></a> at the current
value of <code class="xref py py-meth docutils literal notranslate"><span class="pre">variational_parameters()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>float</dt><dd><p>objective function value</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qmoa.get_final_state">
<span class="sig-name descname"><span class="pre">get_final_state</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.complex128</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qmoa.get_final_state" title="Link to this definition"></a></dt>
<dd><p>Gather the <a class="reference internal" href="glossary.html#term-final-state"><span class="xref std std-term">final state</span></a> to rank 0 of the <code class="docutils literal notranslate"><span class="pre">Ansatz</span></code> MPI subcommunicator.</p>
<p>Requires a previous call to <a class="reference internal" href="#quop_mpi.Ansatz.execute" title="quop_mpi.Ansatz.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code></a>, <a class="reference internal" href="#quop_mpi.Ansatz.evolve_state" title="quop_mpi.Ansatz.evolve_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">evolve_state()</span></code></a>
or <a class="reference internal" href="#quop_mpi.Ansatz.benchmark" title="quop_mpi.Ansatz.benchmark"><code class="xref py py-meth docutils literal notranslate"><span class="pre">benchmark()</span></code></a>. If called after <a class="reference internal" href="#quop_mpi.Ansatz.benchmark" title="quop_mpi.Ansatz.benchmark"><code class="xref py py-meth docutils literal notranslate"><span class="pre">benchmark()</span></code></a> the
gathered state will correspond to the last performed simulation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>ndarray[complex128] or None</dt><dd><p>the final state at rank 0 of the <code class="docutils literal notranslate"><span class="pre">Ansatz</span></code> subcommunicator, <code class="docutils literal notranslate"><span class="pre">None</span></code> otherwise</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qmoa.get_probabilities">
<span class="sig-name descname"><span class="pre">get_probabilities</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.float64</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qmoa.get_probabilities" title="Link to this definition"></a></dt>
<dd><p>Gather probabilities computed from the <a class="reference internal" href="glossary.html#term-final-state"><span class="xref std std-term">final state</span></a> at rank 0
of the <code class="docutils literal notranslate"><span class="pre">Ansatz</span></code> MPI subcommunicator.</p>
<p>Requires a previous call to <a class="reference internal" href="#quop_mpi.Ansatz.execute" title="quop_mpi.Ansatz.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code></a>,
<a class="reference internal" href="#quop_mpi.Ansatz.evolve_state" title="quop_mpi.Ansatz.evolve_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">evolve_state()</span></code></a> or <a class="reference internal" href="#quop_mpi.Ansatz.benchmark" title="quop_mpi.Ansatz.benchmark"><code class="xref py py-meth docutils literal notranslate"><span class="pre">benchmark()</span></code></a>. If called after
<a class="reference internal" href="#quop_mpi.Ansatz.benchmark" title="quop_mpi.Ansatz.benchmark"><code class="xref py py-meth docutils literal notranslate"><span class="pre">benchmark()</span></code></a> the gathered state will correspond to the last
performed simulation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>ndarray[float64] or None</dt><dd><p>1-D real array of state probabilities at rank 0 of the <code class="docutils literal notranslate"><span class="pre">Ansatz</span></code>
subcommunicator, <code class="docutils literal notranslate"><span class="pre">None</span></code> otherwise</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qmoa.grid_point_from_index">
<span class="sig-name descname"><span class="pre">grid_point_from_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qmoa.grid_point_from_index" title="Link to this definition"></a></dt>
<dd><p>Retrieve the corresponding coordinate point from a global index of the
<a class="reference internal" href="glossary.html#term-system-state"><span class="xref std std-term">system state</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">int</span></dt><dd><p>global index of the system state</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray[float64]</dt><dd><p>a 1-D real array containing a grid point in Cartesian coordinates</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qmoa.objective">
<span class="sig-name descname"><span class="pre">objective</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variational_parameters</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qmoa.objective" title="Link to this definition"></a></dt>
<dd><p>Compute the <a class="reference internal" href="glossary.html#term-objective-function"><span class="xref std std-term">objective function</span></a> at <a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational parameters</span></a> 
<code class="docutils literal notranslate"><span class="pre">variational_parameters</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>variational_parameters</strong><span class="classifier">list or ndarray[float]</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>float</dt><dd><p>objective function value</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qmoa.print_optimiser_result">
<span class="sig-name descname"><span class="pre">print_optimiser_result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qmoa.print_optimiser_result" title="Link to this definition"></a></dt>
<dd><p>Print the result returned from the <a class="reference internal" href="glossary.html#term-optimiser"><span class="xref std std-term">optimiser</span></a> for the last
<a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVA</span></a> simulation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qmoa.print_result">
<span class="sig-name descname"><span class="pre">print_result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qmoa.print_result" title="Link to this definition"></a></dt>
<dd><p>Print a summary of the results of the last <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVA</span></a> simulation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qmoa.save">
<span class="sig-name descname"><span class="pre">save</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">config_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">action</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'a'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qmoa.save" title="Link to this definition"></a></dt>
<dd><p>Write the <a class="reference internal" href="glossary.html#term-final-state"><span class="xref std std-term">final state</span></a>, <a class="reference internal" href="glossary.html#term-observables"><span class="xref std std-term">observables</span></a> and results
summary to a HDf5 file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>file_name</strong><span class="classifier">str</span></dt><dd><p>file path to saved data</p>
</dd>
<dt><strong>config_name</strong><span class="classifier">str</span></dt><dd><p>simulation identifier</p>
</dd>
<dt><strong>action</strong><span class="classifier">{‘a’, ‘w’}, optional</span></dt><dd><p>‘a’ to append or ‘w’ to overwrite, by default ‘a’</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Data is saved into a <code class="docutils literal notranslate"><span class="pre">*.h5</span></code> file with the following structure.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>├── config_name
    ├── final_state 
    ├── observables
</pre></div>
</div>
<p>The minimization result is saved in the ‘minimize_result’ attribute of
‘config_name’ as a formatted string.</p>
<p>Multiple configurations with a unique config_name can be stored in the
same .h5 file. HDF5 files are supported in python by the <a class="reference external" href="https://www.h5py.org/">h5py</a> package. With it, a saved configuration can be
accessed as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">h5py</span>

<span class="n">config_name</span> <span class="o">=</span> <span class="s2">&quot;my_simulation&quot;</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">file_name</span> <span class="o">+</span> <span class="s2">&quot;.h5&quot;</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="n">final_state</span> <span class="o">=</span>
<span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">config_name</span><span class="p">][</span><span class="s1">&#39;final_state&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
<span class="n">eigenvalues</span> <span class="o">=</span>
<span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">config_name</span><span class="p">][</span><span class="s1">&#39;eigenvalues&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
<span class="n">observables</span> <span class="o">=</span>
<span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">config_name</span><span class="p">][</span><span class="s1">&#39;observables&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s2">&quot;my_simulation&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;minimize_result&quot;</span><span class="p">])</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The <code class="docutils literal notranslate"><span class="pre">&quot;final_state&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;observables&quot;</span></code> datasets are saved using Fortran
subroutines which make use of parallel HDF5.</p>
<p>The complex values of the final_state array are saved as a compound
datatype consisting of contiguous double precision reals. This is
equivalent to the np.complex128 NumPy datatype. To access this data
without a loss of precision in python, the user must set the
<strong>view</strong> of the NumPy array to np.complex128, rather than casting it
to np.complex128 using the dtype keyword.</p>
<p>Similarly, the observables array, which is saved as an array of
double-precision reals, should have its view set to np.float64.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qmoa.set_depth">
<span class="sig-name descname"><span class="pre">set_depth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">depth</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qmoa.set_depth" title="Link to this definition"></a></dt>
<dd><p>Set the simulated <a class="reference internal" href="glossary.html#term-ansatz-depth"><span class="xref std std-term">ansatz depth</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>depth</strong><span class="classifier">int</span></dt><dd><p>number of ansatz iterations</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qmoa.set_independent_t">
<span class="sig-name descname"><span class="pre">set_independent_t</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">independent</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qmoa.set_independent_t" title="Link to this definition"></a></dt>
<dd><p>Specify simulation with or without independent <a class="reference internal" href="glossary.html#term-unitary-parameter"><span class="xref std std-term">unitary
parameters</span></a> (walk times) over each coordinate
dimension.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>independent</strong><span class="classifier">bool</span></dt><dd><p>simulate a unique walk time in each coordinate dimension if <code class="docutils literal notranslate"><span class="pre">True</span></code>,
all walk times share the same value if <code class="docutils literal notranslate"><span class="pre">False</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qmoa.set_initial_state">
<span class="sig-name descname"><span class="pre">set_initial_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_state_dict</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qmoa.set_initial_state" title="Link to this definition"></a></dt>
<dd><p>Define the <a class="reference internal" href="glossary.html#term-initial-state"><span class="xref std std-term">initial state</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>function</strong><span class="classifier">callable</span></dt><dd><p><a class="reference internal" href="quop_functions.html#term-Initial-State-Function"><span class="xref std std-term">Initial State Function</span></a></p>
</dd>
<dt><strong>initial_state_dict</strong><span class="classifier">FunctionDict, optional</span></dt><dd><p><a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> for the Initial State Function</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qmoa.set_log">
<span class="sig-name descname"><span class="pre">set_log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">action</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'a'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qmoa.set_log" title="Link to this definition"></a></dt>
<dd><p>Creates a CSV in which to save simulation results after a call to
<a class="reference internal" href="#quop_mpi.Ansatz.execute" title="quop_mpi.Ansatz.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>path to the log file</p>
</dd>
<dt><strong>label</strong><span class="classifier">str</span></dt><dd><p>simulation identifier</p>
</dd>
<dt><strong>action</strong><span class="classifier">{‘a’, ‘w’}, optional</span></dt><dd><p>‘a’ to append or ‘w’ overwrite, by default ‘a’</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qmoa.set_mixer">
<span class="sig-name descname"><span class="pre">set_mixer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Cs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qmoa.set_mixer" title="Link to this definition"></a></dt>
<dd><p>Set the circulant <a class="reference internal" href="glossary.html#term-Mixing-Unitary"><span class="xref std std-term">mixing unitary</span></a> <a class="reference internal" href="glossary.html#term-operator"><span class="xref std std-term">operator</span></a> in each
coordinate dimension.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Cs</strong><span class="classifier">list[int]</span></dt><dd><p>specifies the “i-th” symmetric circulant matrix with edges weights
<code class="docutils literal notranslate"><span class="pre">1</span></code>,  <code class="docutils literal notranslate"><span class="pre">Cs[j]</span> <span class="pre">==</span> <span class="pre">1</span></code> cycle graph,  <code class="docutils literal notranslate"><span class="pre">Cs[j]</span> <span class="pre">&gt;</span> <span class="pre">system_size</span> <span class="pre">//</span> <span class="pre">2</span></code>
complete graph</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-meth docutils literal notranslate"><span class="pre">quop_mpi.propagator.composite.ith()</span></code></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qmoa.set_objective">
<span class="sig-name descname"><span class="pre">set_objective</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">objective_dict</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qmoa.set_objective" title="Link to this definition"></a></dt>
<dd><p>Set a custom objective function (i.e. an objective function other
than the expectation value of the prepared state).</p>
<p>The function is called after state evolution - returning a scalar
value that is passed to the minimizer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>function: callable</strong></dt><dd><p>an <a class="reference internal" href="quop_functions.html#term-Objective-Function"><span class="xref std std-term">Objective Function</span></a></p>
</dd>
<dt><strong>objective_dict: FunctionDict, optional</strong></dt><dd><p><a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> for the <cite>Objective Function</cite></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qmoa.set_observables">
<span class="sig-name descname"><span class="pre">set_observables</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">observable_dict</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qmoa.set_observables" title="Link to this definition"></a></dt>
<dd><p>Specify the <a class="reference internal" href="glossary.html#term-observables"><span class="xref std std-term">observables</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>function</strong><span class="classifier">callable or int</span></dt><dd><p>an <a class="reference internal" href="quop_functions.html#term-Observables-Function"><span class="xref std std-term">Observables Function</span></a> or an integer specifying the index
of a phase-shift unitary in the list passed to the
<a class="reference internal" href="#quop_mpi.Ansatz.set_observables" title="quop_mpi.Ansatz.set_observables"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_observables()</span></code></a> whose exponent contains the
observable vector.</p>
</dd>
<dt><strong>observables_dict: FunctionDict, optional</strong></dt><dd><p><a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> for the Observables Function</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qmoa.set_optimiser">
<span class="sig-name descname"><span class="pre">set_optimiser</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">optimiser</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimiser_args</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimiser_log</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qmoa.set_optimiser" title="Link to this definition"></a></dt>
<dd><p>Define the classical <a class="reference internal" href="glossary.html#term-optimiser"><span class="xref std std-term">optimiser</span></a> for <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVA</span></a> simulation.</p>
<p>Optionally allows for specification of arguments passed to the optimiser
and fields in the optimiser dictionary to write to the log file (see
<a class="reference internal" href="#quop_mpi.Ansatz.set_log" title="quop_mpi.Ansatz.set_log"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_log()</span></code></a>). QuOp_MPI supports optimisers provided by SciPy
through its minimize method <a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html">minimize</a>
and optimisers provided by the <a class="reference external" href="http://nlopt.readthedocs.io/en/latest/">NLopt</a> package with respect to
minimisation with scalar constraints through a SciPy-like interface.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>optimiser: {‘scipy’, ‘nlopt’}</strong></dt><dd><p>‘scipy’ to use the SciPy, ‘nlopt’ to use NLopt, or a callable
QuOp_MPI-compatible optimisation function.</p>
</dd>
<dt><strong>optimiser_args: dict</strong></dt><dd><p>arguments to pass to the optimiser</p>
</dd>
<dt><strong>optimiser_log: list[str]</strong></dt><dd><p>results of the optimisation process are stored in a dictionary.
These values may be logged by passing a list of the corresponding
keys</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>The default optimiser is the BFGS algorithm, which is set internally as
follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Ansatz</span><span class="o">.</span><span class="n">set_optimiser</span><span class="p">(</span> <span class="s1">&#39;scipy&#39;</span><span class="p">,</span>
        <span class="p">{</span><span class="s1">&#39;method&#39;</span><span class="p">:</span><span class="s1">&#39;BFGS&#39;</span><span class="p">,</span><span class="s1">&#39;options&#39;</span><span class="p">:{</span><span class="s1">&#39;gtol&#39;</span><span class="p">:</span><span class="mf">1e-3</span><span class="p">}},</span>
                    <span class="p">[</span><span class="s1">&#39;fun&#39;</span><span class="p">,</span><span class="s1">&#39;nfev&#39;</span><span class="p">,</span><span class="s1">&#39;success&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qmoa.set_parallel_jacobian">
<span class="sig-name descname"><span class="pre">set_parallel_jacobian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes_per_subcomm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">processes_per_node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxcomm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Callable</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'forward'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qmoa.set_parallel_jacobian" title="Link to this definition"></a></dt>
<dd><p>Specify <a class="reference internal" href="glossary.html#term-optimiser"><span class="xref std std-term">optimisation</span></a> of the <a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational
parameters</span></a> using parallel computation of the jacobian.</p>
<p>This creates MPI subcommunicators containing duplicates of the
<a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ansatz</span></code></a> instance which return partial derivative information to
the root MPI process during optimisation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nodes_per_subcomm</strong><span class="classifier">int</span></dt><dd><p>MPI nodes per subcommunicator</p>
</dd>
<dt><strong>processes_per_node</strong><span class="classifier">int</span></dt><dd><p>MPI processors associated with each node</p>
</dd>
<dt><strong>maxcomm</strong><span class="classifier">int</span></dt><dd><p>maximum number of created MPI subcommunicators (and <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ansatz</span></code></a>
instance duplicates) if <cite>nodes_per_subcomm &gt; 1</cite>, or the maximum
number of MPI subcommunicators per node if <cite>nodes_per_subcomm = 1</cite></p>
</dd>
<dt><strong>method :{‘forward’, ‘central’} or callable, optional</strong></dt><dd><p>‘forward’ or ‘central’ to used the forward difference or central
difference method for numerical approximation of the partial
derivatives, or a QuOp Jacobian Function, by default ‘forward’</p>
</dd>
<dt><strong>h</strong><span class="classifier">float, optional</span></dt><dd><p>step-size used by the forward or central difference methods, by
default <code class="docutils literal notranslate"><span class="pre">np.sqrt(np.finfo(float).eps)</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qmoa.set_parameter_map">
<span class="sig-name descname"><span class="pre">set_parameter_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mapping_fn</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">np.ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">np.ndarray</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mapping_dict</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qmoa.set_parameter_map" title="Link to this definition"></a></dt>
<dd><p>Register a mapping from a subset of optimisable parameters to the full
set of variational parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mapping_fn</strong><span class="classifier">callable</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">mapping_fn(free_vec,</span> <span class="pre">*args,</span> <span class="pre">**kwargs)</span> <span class="pre">-&gt;</span> <span class="pre">full_vec</span></code>.
<em>free_vec</em> is the vector presented to the optimiser;
<em>full_vec</em> must have length <code class="docutils literal notranslate"><span class="pre">ansatz_depth</span> <span class="pre">*</span> <span class="pre">total_params</span></code>.</p>
</dd>
<dt><strong>mapping_dict</strong><span class="classifier">FunctionDict, optional</span></dt><dd><p>FunctionDict supplying extra positional and keyword arguments
to the mapping function.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qmoa.set_params">
<span class="sig-name descname"><span class="pre">set_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">param_function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param_dict</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qmoa.set_params" title="Link to this definition"></a></dt>
<dd><p>Define the <a class="reference internal" href="quop_functions.html#term-Parameter-Function"><span class="xref std std-term">Parameter Function</span></a> for the 
<a class="reference internal" href="glossary.html#term-Phase-Shift-Unitary"><span class="xref std std-term">phase-shift</span></a> and 
<a class="reference internal" href="glossary.html#term-Mixing-Unitary"><span class="xref std std-term">mixing</span></a> unitaries.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>param_function</strong><span class="classifier">Callable</span></dt><dd><p>a <a class="reference internal" href="quop_functions.html#term-Parameter-Function"><span class="xref std std-term">Parameter Function</span></a></p>
</dd>
<dt><strong>param_dict</strong><span class="classifier">FunctionDict</span></dt><dd><p><a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> for <code class="docutils literal notranslate"><span class="pre">param_function</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qmoa.set_qualities">
<span class="sig-name descname"><span class="pre">set_qualities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator_dict</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qmoa.set_qualities" title="Link to this definition"></a></dt>
<dd><p>Define the <a class="reference internal" href="glossary.html#term-observables"><span class="xref std std-term">observables</span></a> and <a class="reference internal" href="glossary.html#term-Phase-Shift-Unitary"><span class="xref std std-term">phase-shift unitary</span></a> <a class="reference internal" href="glossary.html#term-operator"><span class="xref std std-term">operator</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>function</strong><span class="classifier">Callable</span></dt><dd><p>an <a class="reference internal" href="quop_functions.html#term-Operator-Function"><span class="xref std std-term">Operator Function</span></a></p>
</dd>
<dt><strong>operator_dict</strong><span class="classifier">FunctionDict, optional</span></dt><dd><p><a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> for <code class="docutils literal notranslate"><span class="pre">function</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qmoa.set_sampling">
<span class="sig-name descname"><span class="pre">set_sampling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample_block_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_sample_iterations</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_dict</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qmoa.set_sampling" title="Link to this definition"></a></dt>
<dd><p>Compute the <a class="reference internal" href="glossary.html#term-objective-function"><span class="xref std std-term">objective function</span></a> using simulated sampling.</p>
<p>Samples are taken in blocks of <cite>sample_block_size</cite>. These are passed as
a list of lists to <code class="docutils literal notranslate"><span class="pre">function</span></code> (a <a class="reference internal" href="quop_functions.html#term-Sampling-Function"><span class="xref std std-term">Sampling Function</span></a>), which returns a value for expectation
value/objective function and a boolean that indicates wether the sampled
result should be passed to the classical optimiser.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">function</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, the <a class="reference internal" href="glossary.html#term-objective-function"><span class="xref std std-term">objective function</span></a> is
computed as the mean of <code class="docutils literal notranslate"><span class="pre">sample_block_size</span></code> shots.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sample_block_size</strong><span class="classifier">int</span></dt><dd><p>number of shots taken between successive computation of the
expectation value/objective function</p>
</dd>
<dt><strong>function</strong><span class="classifier">callable, optional</span></dt><dd><p><a class="reference internal" href="quop_functions.html#term-Sampling-Function"><span class="xref std std-term">Sampling Function</span></a></p>
</dd>
<dt><strong>max_sample_iterations</strong><span class="classifier">int, optional</span></dt><dd><p>maximum number of sample blocks per computation of the expectation
value/objective function,  overrides the boolean returned by
<code class="docutils literal notranslate"><span class="pre">function</span></code>, by default 100</p>
</dd>
<dt><strong>sampling_dict</strong><span class="classifier">FunctionDict, optional</span></dt><dd><p><a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> for the Sampling Function</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qmoa.set_seed">
<span class="sig-name descname"><span class="pre">set_seed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qmoa.set_seed" title="Link to this definition"></a></dt>
<dd><p>Integer for seeding of random number generation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>seed</strong><span class="classifier">int</span></dt><dd><p>seeds the generation of random parameters</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qmoa.set_unitaries">
<span class="sig-name descname"><span class="pre">set_unitaries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unitaries</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#quop_mpi.Unitary" title="quop_mpi.Unitary.Unitary"><span class="pre">Unitary</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qmoa.set_unitaries" title="Link to this definition"></a></dt>
<dd><p>Define the <a class="reference internal" href="glossary.html#term-ansatz-unitary"><span class="xref std std-term">ansatz unitary</span></a>.</p>
<blockquote>
<div><p><a class="reference internal" href="glossary.html#term-unitary"><span class="xref std std-term">Unitaries</span></a> are passed as a python list in order of
application from left to right.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>unitaries: list[unitary]</strong></dt><dd><p>list of <a class="reference internal" href="glossary.html#term-unitary"><span class="xref std std-term">unitaries</span></a> specifying the action of one
<a class="reference internal" href="glossary.html#term-ansatz-depth"><span class="xref std std-term">ansatz iteration</span></a></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qmoa.unset_sampling">
<span class="sig-name descname"><span class="pre">unset_sampling</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qmoa.unset_sampling" title="Link to this definition"></a></dt>
<dd><p>Revert to simulation using exact computation of the
<a class="reference internal" href="glossary.html#term-objective-function"><span class="xref std std-term">objective function</span></a>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qowe">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quop_mpi.algorithm.multivariable.</span></span><span class="sig-name descname"><span class="pre">qowe</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Ns</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deltas</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mins</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">MPI_COMM</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mpi4py.MPI.Intracomm</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">mpi4py.MPI.COMM_WORLD</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qowe" title="Link to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qowe.benchmark">
<span class="sig-name descname"><span class="pre">benchmark</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ansatz_depths</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repeats</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_parameters</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param_persist</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'test'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_action</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'a'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_limit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suspend_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qowe.benchmark" title="Link to this definition"></a></dt>
<dd><p>A method by which to study how a QVA performs as the number
of ansatz iterations&lt;ansatz depth&gt; increases.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ansatz_depths</strong><span class="classifier">iterable[int]</span></dt><dd><p>integers specifying a sequence of ansatz depths&lt;ansatz depth&gt;</p>
</dd>
<dt><strong>repeats</strong><span class="classifier">int</span></dt><dd><p>number of repeats at each ansatz depth</p>
</dd>
<dt><strong>initial_parameters: list[float] or ndarray[float], optional</strong></dt><dd><p>** Must be defined if a parameter mapping function is set. **
initial variational parameter values, if not present these are generated
using the default parameter generation methods of the ansatz unitaries.</p>
</dd>
<dt><strong>param_persist</strong><span class="classifier">bool, optional</span></dt><dd><p>if True the optimised variational parameter values which achieved
the lowest objective function value for all repeats at ansatz_depth
will be used as starting parameters for the first
ansatz_depth * total_params at ansatz_depth += 1. if a parameter
map is set, the initial parameters will update whenever the 
objective function reaches a new minimum.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool, optional</span></dt><dd><p>if True, print current the ansatz depth, repeat number and
optimisation results (default True)</p>
</dd>
<dt><strong>filename</strong><span class="classifier">str or None, optional</span></dt><dd><p>name of <a href="#id26"><span class="problematic" id="id27">*</span></a>.h5 file in which to save the optimised system state and observables</p>
</dd>
<dt><strong>label</strong><span class="classifier">str, optional</span></dt><dd><p>if filename is not None, <a href="#id28"><span class="problematic" id="id29">*</span></a>.h5 data will be saved as
“filename/label_depth_repeat” (default “test”)</p>
</dd>
<dt><strong>save_action</strong><span class="classifier">{‘a’, ‘w’}, optional</span></dt><dd><p>action taken during first file write: ‘a’ to append, ‘w’ to overwrite (default ‘a’)</p>
</dd>
<dt><strong>time_limit</strong><span class="classifier">int or None, optional</span></dt><dd><p>total allocated in-program time in seconds; if exceeded, the benchmark is suspended</p>
</dd>
<dt><strong>suspend_path</strong><span class="classifier">str or None, optional</span></dt><dd><p>path to the suspend file if time_limit is not None</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qowe.evaluate">
<span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variational_parameters</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qowe.evaluate" title="Link to this definition"></a></dt>
<dd><p>Lazily computes the <a class="reference internal" href="glossary.html#term-objective-function"><span class="xref std std-term">objective function</span></a> value.</p>
<p>The <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ansatz</span></code></a> instance stores the last <a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational
parameters</span></a> passed to <code class="docutils literal notranslate"><span class="pre">evaluate</span></code> and the corresponding objective
function value. If the input variational parameters match,
re-computation of the <a class="reference internal" href="glossary.html#term-final-state"><span class="xref std std-term">final state</span></a> is skipped and the previously
computed objective function value is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>variational_parameters</strong><span class="classifier">list[float] or ndarray[float]</span></dt><dd><p>1-D <code class="docutils literal notranslate"><span class="pre">(ansatz_depth</span> <span class="pre">*</span> <span class="pre">total_params,)</span></code> real array of variational
parameters</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>float</dt><dd><p>objective function value</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qowe.evolve_state">
<span class="sig-name descname"><span class="pre">evolve_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variational_parameters</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qowe.evolve_state" title="Link to this definition"></a></dt>
<dd><p>Compute the <a class="reference internal" href="glossary.html#term-system-state"><span class="xref std std-term">system state</span></a> under the action of the
<a class="reference internal" href="glossary.html#term-ansatz-unitary"><span class="xref std std-term">ansatz unitary</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>variational_parameters</strong><span class="classifier">list[float] or ndarray[float]</span></dt><dd><p>1-D <code class="docutils literal notranslate"><span class="pre">(ansatz_depth</span> <span class="pre">*</span> <span class="pre">total_params,)</span></code> real array of
<a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational parameters</span></a>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#quop_mpi.Ansatz.set_unitaries" title="quop_mpi.Ansatz.set_unitaries"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_unitaries()</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qowe.execute">
<span class="sig-name descname"><span class="pre">execute</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variational_parameters</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qowe.execute" title="Link to this definition"></a></dt>
<dd><p>Simulate a <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVA</span></a>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">variational_parameters</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, initial parameter values are
generated using the <a class="reference internal" href="quop_functions.html#term-Parameter-Function"><span class="xref std std-term">Parameter Function</span></a> of the corresponding
<code class="docutils literal notranslate"><span class="pre">unitary</span></code> instances.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>variational_parameters</strong><span class="classifier">list[float] or ndarray[float]</span></dt><dd><p>1-D <code class="docutils literal notranslate"><span class="pre">(ansatz_depth</span> <span class="pre">*</span> <span class="pre">total_params,)</span></code> real array of
<a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational parameters</span></a></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qowe.gen_initial_params">
<span class="sig-name descname"><span class="pre">gen_initial_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ansatz_depth</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qowe.gen_initial_params" title="Link to this definition"></a></dt>
<dd><p>Generate initial <a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational parameters</span></a>.</p>
<p>Values are generated using the <a class="reference internal" href="quop_functions.html#term-Parameter-Function"><span class="xref std std-term">Parameter Function</span></a> associated
with each <code class="docutils literal notranslate"><span class="pre">unitary</span></code> passed to the <a class="reference internal" href="#quop_mpi.Ansatz.set_unitaries" title="quop_mpi.Ansatz.set_unitaries"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_unitaries()</span></code></a>
method.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="docutils literal notranslate"><span class="pre">ansatz_depth</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code> the <a class="reference internal" href="glossary.html#term-ansatz-depth"><span class="xref std std-term">ansatz depth</span></a> defaults 
to <cite>1</cite> or the depth specified by the <a class="reference internal" href="#quop_mpi.Ansatz.set_depth" title="quop_mpi.Ansatz.set_depth"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_depth()</span></code></a> method.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ansatz_depth</strong><span class="classifier">int, optional</span></dt><dd><p>number of <a class="reference internal" href="glossary.html#term-ansatz-depth"><span class="xref std std-term">ansatz iterations</span></a></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray[float64]</dt><dd><p>1-D <code class="docutils literal notranslate"><span class="pre">(ansatz_depth</span> <span class="pre">*</span> <span class="pre">total_params,)</span></code> real array of variational
parameters</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qowe.get_expectation_value">
<span class="sig-name descname"><span class="pre">get_expectation_value</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qowe.get_expectation_value" title="Link to this definition"></a></dt>
<dd><p>Compute the <a class="reference internal" href="glossary.html#term-objective-function"><span class="xref std std-term">objective function</span></a> at the current
value of <code class="xref py py-meth docutils literal notranslate"><span class="pre">variational_parameters()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>float</dt><dd><p>objective function value</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qowe.get_final_state">
<span class="sig-name descname"><span class="pre">get_final_state</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.complex128</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qowe.get_final_state" title="Link to this definition"></a></dt>
<dd><p>Gather the <a class="reference internal" href="glossary.html#term-final-state"><span class="xref std std-term">final state</span></a> to rank 0 of the <code class="docutils literal notranslate"><span class="pre">Ansatz</span></code> MPI subcommunicator.</p>
<p>Requires a previous call to <a class="reference internal" href="#quop_mpi.Ansatz.execute" title="quop_mpi.Ansatz.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code></a>, <a class="reference internal" href="#quop_mpi.Ansatz.evolve_state" title="quop_mpi.Ansatz.evolve_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">evolve_state()</span></code></a>
or <a class="reference internal" href="#quop_mpi.Ansatz.benchmark" title="quop_mpi.Ansatz.benchmark"><code class="xref py py-meth docutils literal notranslate"><span class="pre">benchmark()</span></code></a>. If called after <a class="reference internal" href="#quop_mpi.Ansatz.benchmark" title="quop_mpi.Ansatz.benchmark"><code class="xref py py-meth docutils literal notranslate"><span class="pre">benchmark()</span></code></a> the
gathered state will correspond to the last performed simulation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>ndarray[complex128] or None</dt><dd><p>the final state at rank 0 of the <code class="docutils literal notranslate"><span class="pre">Ansatz</span></code> subcommunicator, <code class="docutils literal notranslate"><span class="pre">None</span></code> otherwise</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qowe.get_probabilities">
<span class="sig-name descname"><span class="pre">get_probabilities</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.float64</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qowe.get_probabilities" title="Link to this definition"></a></dt>
<dd><p>Gather probabilities computed from the <a class="reference internal" href="glossary.html#term-final-state"><span class="xref std std-term">final state</span></a> at rank 0
of the <code class="docutils literal notranslate"><span class="pre">Ansatz</span></code> MPI subcommunicator.</p>
<p>Requires a previous call to <a class="reference internal" href="#quop_mpi.Ansatz.execute" title="quop_mpi.Ansatz.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code></a>,
<a class="reference internal" href="#quop_mpi.Ansatz.evolve_state" title="quop_mpi.Ansatz.evolve_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">evolve_state()</span></code></a> or <a class="reference internal" href="#quop_mpi.Ansatz.benchmark" title="quop_mpi.Ansatz.benchmark"><code class="xref py py-meth docutils literal notranslate"><span class="pre">benchmark()</span></code></a>. If called after
<a class="reference internal" href="#quop_mpi.Ansatz.benchmark" title="quop_mpi.Ansatz.benchmark"><code class="xref py py-meth docutils literal notranslate"><span class="pre">benchmark()</span></code></a> the gathered state will correspond to the last
performed simulation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>ndarray[float64] or None</dt><dd><p>1-D real array of state probabilities at rank 0 of the <code class="docutils literal notranslate"><span class="pre">Ansatz</span></code>
subcommunicator, <code class="docutils literal notranslate"><span class="pre">None</span></code> otherwise</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qowe.grid_point_from_index">
<span class="sig-name descname"><span class="pre">grid_point_from_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qowe.grid_point_from_index" title="Link to this definition"></a></dt>
<dd><p>Retrieve the corresponding coordinate point from a global index of the
<a class="reference internal" href="glossary.html#term-system-state"><span class="xref std std-term">system state</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">int</span></dt><dd><p>global index of the system state</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray[float64]</dt><dd><p>a 1-D real array containing a grid point in Cartesian coordinates</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qowe.objective">
<span class="sig-name descname"><span class="pre">objective</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variational_parameters</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qowe.objective" title="Link to this definition"></a></dt>
<dd><p>Compute the <a class="reference internal" href="glossary.html#term-objective-function"><span class="xref std std-term">objective function</span></a> at <a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational parameters</span></a> 
<code class="docutils literal notranslate"><span class="pre">variational_parameters</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>variational_parameters</strong><span class="classifier">list or ndarray[float]</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>float</dt><dd><p>objective function value</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qowe.print_optimiser_result">
<span class="sig-name descname"><span class="pre">print_optimiser_result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qowe.print_optimiser_result" title="Link to this definition"></a></dt>
<dd><p>Print the result returned from the <a class="reference internal" href="glossary.html#term-optimiser"><span class="xref std std-term">optimiser</span></a> for the last
<a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVA</span></a> simulation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qowe.print_result">
<span class="sig-name descname"><span class="pre">print_result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qowe.print_result" title="Link to this definition"></a></dt>
<dd><p>Print a summary of the results of the last <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVA</span></a> simulation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qowe.save">
<span class="sig-name descname"><span class="pre">save</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">config_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">action</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'a'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qowe.save" title="Link to this definition"></a></dt>
<dd><p>Write the <a class="reference internal" href="glossary.html#term-final-state"><span class="xref std std-term">final state</span></a>, <a class="reference internal" href="glossary.html#term-observables"><span class="xref std std-term">observables</span></a> and results
summary to a HDf5 file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>file_name</strong><span class="classifier">str</span></dt><dd><p>file path to saved data</p>
</dd>
<dt><strong>config_name</strong><span class="classifier">str</span></dt><dd><p>simulation identifier</p>
</dd>
<dt><strong>action</strong><span class="classifier">{‘a’, ‘w’}, optional</span></dt><dd><p>‘a’ to append or ‘w’ to overwrite, by default ‘a’</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Data is saved into a <code class="docutils literal notranslate"><span class="pre">*.h5</span></code> file with the following structure.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>├── config_name
    ├── final_state 
    ├── observables
</pre></div>
</div>
<p>The minimization result is saved in the ‘minimize_result’ attribute of
‘config_name’ as a formatted string.</p>
<p>Multiple configurations with a unique config_name can be stored in the
same .h5 file. HDF5 files are supported in python by the <a class="reference external" href="https://www.h5py.org/">h5py</a> package. With it, a saved configuration can be
accessed as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">h5py</span>

<span class="n">config_name</span> <span class="o">=</span> <span class="s2">&quot;my_simulation&quot;</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">file_name</span> <span class="o">+</span> <span class="s2">&quot;.h5&quot;</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="n">final_state</span> <span class="o">=</span>
<span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">config_name</span><span class="p">][</span><span class="s1">&#39;final_state&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
<span class="n">eigenvalues</span> <span class="o">=</span>
<span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">config_name</span><span class="p">][</span><span class="s1">&#39;eigenvalues&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
<span class="n">observables</span> <span class="o">=</span>
<span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">config_name</span><span class="p">][</span><span class="s1">&#39;observables&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s2">&quot;my_simulation&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;minimize_result&quot;</span><span class="p">])</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The <code class="docutils literal notranslate"><span class="pre">&quot;final_state&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;observables&quot;</span></code> datasets are saved using Fortran
subroutines which make use of parallel HDF5.</p>
<p>The complex values of the final_state array are saved as a compound
datatype consisting of contiguous double precision reals. This is
equivalent to the np.complex128 NumPy datatype. To access this data
without a loss of precision in python, the user must set the
<strong>view</strong> of the NumPy array to np.complex128, rather than casting it
to np.complex128 using the dtype keyword.</p>
<p>Similarly, the observables array, which is saved as an array of
double-precision reals, should have its view set to np.float64.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qowe.set_depth">
<span class="sig-name descname"><span class="pre">set_depth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">depth</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qowe.set_depth" title="Link to this definition"></a></dt>
<dd><p>Set the simulated <a class="reference internal" href="glossary.html#term-ansatz-depth"><span class="xref std std-term">ansatz depth</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>depth</strong><span class="classifier">int</span></dt><dd><p>number of ansatz iterations</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qowe.set_independent_t">
<span class="sig-name descname"><span class="pre">set_independent_t</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">independent</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qowe.set_independent_t" title="Link to this definition"></a></dt>
<dd><p>Specify simulation with or without independent <a class="reference internal" href="glossary.html#term-unitary-parameter"><span class="xref std std-term">unitary
parameters</span></a> (walk times) over each coordinate
dimension.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>independent</strong><span class="classifier">bool</span></dt><dd><p>simulate a unique walk time in each coordinate dimension if <code class="docutils literal notranslate"><span class="pre">True</span></code>,
all walk times share the same value if <code class="docutils literal notranslate"><span class="pre">False</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qowe.set_initial_state">
<span class="sig-name descname"><span class="pre">set_initial_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_state_dict</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qowe.set_initial_state" title="Link to this definition"></a></dt>
<dd><p>Define the <a class="reference internal" href="glossary.html#term-initial-state"><span class="xref std std-term">initial state</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>function</strong><span class="classifier">callable</span></dt><dd><p><a class="reference internal" href="quop_functions.html#term-Initial-State-Function"><span class="xref std std-term">Initial State Function</span></a></p>
</dd>
<dt><strong>initial_state_dict</strong><span class="classifier">FunctionDict, optional</span></dt><dd><p><a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> for the Initial State Function</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qowe.set_log">
<span class="sig-name descname"><span class="pre">set_log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">action</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'a'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qowe.set_log" title="Link to this definition"></a></dt>
<dd><p>Creates a CSV in which to save simulation results after a call to
<a class="reference internal" href="#quop_mpi.Ansatz.execute" title="quop_mpi.Ansatz.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>path to the log file</p>
</dd>
<dt><strong>label</strong><span class="classifier">str</span></dt><dd><p>simulation identifier</p>
</dd>
<dt><strong>action</strong><span class="classifier">{‘a’, ‘w’}, optional</span></dt><dd><p>‘a’ to append or ‘w’ overwrite, by default ‘a’</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qowe.set_objective">
<span class="sig-name descname"><span class="pre">set_objective</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">objective_dict</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qowe.set_objective" title="Link to this definition"></a></dt>
<dd><p>Set a custom objective function (i.e. an objective function other
than the expectation value of the prepared state).</p>
<p>The function is called after state evolution - returning a scalar
value that is passed to the minimizer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>function: callable</strong></dt><dd><p>an <a class="reference internal" href="quop_functions.html#term-Objective-Function"><span class="xref std std-term">Objective Function</span></a></p>
</dd>
<dt><strong>objective_dict: FunctionDict, optional</strong></dt><dd><p><a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> for the <cite>Objective Function</cite></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qowe.set_observables">
<span class="sig-name descname"><span class="pre">set_observables</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">observable_dict</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qowe.set_observables" title="Link to this definition"></a></dt>
<dd><p>Specify the <a class="reference internal" href="glossary.html#term-observables"><span class="xref std std-term">observables</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>function</strong><span class="classifier">callable or int</span></dt><dd><p>an <a class="reference internal" href="quop_functions.html#term-Observables-Function"><span class="xref std std-term">Observables Function</span></a> or an integer specifying the index
of a phase-shift unitary in the list passed to the
<a class="reference internal" href="#quop_mpi.Ansatz.set_observables" title="quop_mpi.Ansatz.set_observables"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_observables()</span></code></a> whose exponent contains the
observable vector.</p>
</dd>
<dt><strong>observables_dict: FunctionDict, optional</strong></dt><dd><p><a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> for the Observables Function</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qowe.set_optimiser">
<span class="sig-name descname"><span class="pre">set_optimiser</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">optimiser</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimiser_args</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimiser_log</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qowe.set_optimiser" title="Link to this definition"></a></dt>
<dd><p>Define the classical <a class="reference internal" href="glossary.html#term-optimiser"><span class="xref std std-term">optimiser</span></a> for <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVA</span></a> simulation.</p>
<p>Optionally allows for specification of arguments passed to the optimiser
and fields in the optimiser dictionary to write to the log file (see
<a class="reference internal" href="#quop_mpi.Ansatz.set_log" title="quop_mpi.Ansatz.set_log"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_log()</span></code></a>). QuOp_MPI supports optimisers provided by SciPy
through its minimize method <a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html">minimize</a>
and optimisers provided by the <a class="reference external" href="http://nlopt.readthedocs.io/en/latest/">NLopt</a> package with respect to
minimisation with scalar constraints through a SciPy-like interface.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>optimiser: {‘scipy’, ‘nlopt’}</strong></dt><dd><p>‘scipy’ to use the SciPy, ‘nlopt’ to use NLopt, or a callable
QuOp_MPI-compatible optimisation function.</p>
</dd>
<dt><strong>optimiser_args: dict</strong></dt><dd><p>arguments to pass to the optimiser</p>
</dd>
<dt><strong>optimiser_log: list[str]</strong></dt><dd><p>results of the optimisation process are stored in a dictionary.
These values may be logged by passing a list of the corresponding
keys</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>The default optimiser is the BFGS algorithm, which is set internally as
follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Ansatz</span><span class="o">.</span><span class="n">set_optimiser</span><span class="p">(</span> <span class="s1">&#39;scipy&#39;</span><span class="p">,</span>
        <span class="p">{</span><span class="s1">&#39;method&#39;</span><span class="p">:</span><span class="s1">&#39;BFGS&#39;</span><span class="p">,</span><span class="s1">&#39;options&#39;</span><span class="p">:{</span><span class="s1">&#39;gtol&#39;</span><span class="p">:</span><span class="mf">1e-3</span><span class="p">}},</span>
                    <span class="p">[</span><span class="s1">&#39;fun&#39;</span><span class="p">,</span><span class="s1">&#39;nfev&#39;</span><span class="p">,</span><span class="s1">&#39;success&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qowe.set_parallel_jacobian">
<span class="sig-name descname"><span class="pre">set_parallel_jacobian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes_per_subcomm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">processes_per_node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxcomm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Callable</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'forward'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qowe.set_parallel_jacobian" title="Link to this definition"></a></dt>
<dd><p>Specify <a class="reference internal" href="glossary.html#term-optimiser"><span class="xref std std-term">optimisation</span></a> of the <a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational
parameters</span></a> using parallel computation of the jacobian.</p>
<p>This creates MPI subcommunicators containing duplicates of the
<a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ansatz</span></code></a> instance which return partial derivative information to
the root MPI process during optimisation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nodes_per_subcomm</strong><span class="classifier">int</span></dt><dd><p>MPI nodes per subcommunicator</p>
</dd>
<dt><strong>processes_per_node</strong><span class="classifier">int</span></dt><dd><p>MPI processors associated with each node</p>
</dd>
<dt><strong>maxcomm</strong><span class="classifier">int</span></dt><dd><p>maximum number of created MPI subcommunicators (and <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ansatz</span></code></a>
instance duplicates) if <cite>nodes_per_subcomm &gt; 1</cite>, or the maximum
number of MPI subcommunicators per node if <cite>nodes_per_subcomm = 1</cite></p>
</dd>
<dt><strong>method :{‘forward’, ‘central’} or callable, optional</strong></dt><dd><p>‘forward’ or ‘central’ to used the forward difference or central
difference method for numerical approximation of the partial
derivatives, or a QuOp Jacobian Function, by default ‘forward’</p>
</dd>
<dt><strong>h</strong><span class="classifier">float, optional</span></dt><dd><p>step-size used by the forward or central difference methods, by
default <code class="docutils literal notranslate"><span class="pre">np.sqrt(np.finfo(float).eps)</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qowe.set_parameter_map">
<span class="sig-name descname"><span class="pre">set_parameter_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mapping_fn</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">np.ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">np.ndarray</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mapping_dict</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qowe.set_parameter_map" title="Link to this definition"></a></dt>
<dd><p>Register a mapping from a subset of optimisable parameters to the full
set of variational parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mapping_fn</strong><span class="classifier">callable</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">mapping_fn(free_vec,</span> <span class="pre">*args,</span> <span class="pre">**kwargs)</span> <span class="pre">-&gt;</span> <span class="pre">full_vec</span></code>.
<em>free_vec</em> is the vector presented to the optimiser;
<em>full_vec</em> must have length <code class="docutils literal notranslate"><span class="pre">ansatz_depth</span> <span class="pre">*</span> <span class="pre">total_params</span></code>.</p>
</dd>
<dt><strong>mapping_dict</strong><span class="classifier">FunctionDict, optional</span></dt><dd><p>FunctionDict supplying extra positional and keyword arguments
to the mapping function.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qowe.set_params">
<span class="sig-name descname"><span class="pre">set_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">param_function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param_dict</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qowe.set_params" title="Link to this definition"></a></dt>
<dd><p>Define the <a class="reference internal" href="quop_functions.html#term-Parameter-Function"><span class="xref std std-term">Parameter Function</span></a> for the 
<a class="reference internal" href="glossary.html#term-Phase-Shift-Unitary"><span class="xref std std-term">phase-shift</span></a> and 
<a class="reference internal" href="glossary.html#term-Mixing-Unitary"><span class="xref std std-term">mixing</span></a> unitaries.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>param_function</strong><span class="classifier">Callable</span></dt><dd><p>a <a class="reference internal" href="quop_functions.html#term-Parameter-Function"><span class="xref std std-term">Parameter Function</span></a></p>
</dd>
<dt><strong>param_dict</strong><span class="classifier">FunctionDict</span></dt><dd><p><a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> for <code class="docutils literal notranslate"><span class="pre">param_function</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qowe.set_qualities">
<span class="sig-name descname"><span class="pre">set_qualities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator_dict</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qowe.set_qualities" title="Link to this definition"></a></dt>
<dd><p>Define the <a class="reference internal" href="glossary.html#term-observables"><span class="xref std std-term">observables</span></a> and <a class="reference internal" href="glossary.html#term-Phase-Shift-Unitary"><span class="xref std std-term">phase-shift unitary</span></a> <a class="reference internal" href="glossary.html#term-operator"><span class="xref std std-term">operator</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>function</strong><span class="classifier">Callable</span></dt><dd><p>an <a class="reference internal" href="quop_functions.html#term-Operator-Function"><span class="xref std std-term">Operator Function</span></a></p>
</dd>
<dt><strong>operator_dict</strong><span class="classifier">FunctionDict, optional</span></dt><dd><p><a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> for <code class="docutils literal notranslate"><span class="pre">function</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qowe.set_sampling">
<span class="sig-name descname"><span class="pre">set_sampling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample_block_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_sample_iterations</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_dict</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qowe.set_sampling" title="Link to this definition"></a></dt>
<dd><p>Compute the <a class="reference internal" href="glossary.html#term-objective-function"><span class="xref std std-term">objective function</span></a> using simulated sampling.</p>
<p>Samples are taken in blocks of <cite>sample_block_size</cite>. These are passed as
a list of lists to <code class="docutils literal notranslate"><span class="pre">function</span></code> (a <a class="reference internal" href="quop_functions.html#term-Sampling-Function"><span class="xref std std-term">Sampling Function</span></a>), which returns a value for expectation
value/objective function and a boolean that indicates wether the sampled
result should be passed to the classical optimiser.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">function</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, the <a class="reference internal" href="glossary.html#term-objective-function"><span class="xref std std-term">objective function</span></a> is
computed as the mean of <code class="docutils literal notranslate"><span class="pre">sample_block_size</span></code> shots.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sample_block_size</strong><span class="classifier">int</span></dt><dd><p>number of shots taken between successive computation of the
expectation value/objective function</p>
</dd>
<dt><strong>function</strong><span class="classifier">callable, optional</span></dt><dd><p><a class="reference internal" href="quop_functions.html#term-Sampling-Function"><span class="xref std std-term">Sampling Function</span></a></p>
</dd>
<dt><strong>max_sample_iterations</strong><span class="classifier">int, optional</span></dt><dd><p>maximum number of sample blocks per computation of the expectation
value/objective function,  overrides the boolean returned by
<code class="docutils literal notranslate"><span class="pre">function</span></code>, by default 100</p>
</dd>
<dt><strong>sampling_dict</strong><span class="classifier">FunctionDict, optional</span></dt><dd><p><a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> for the Sampling Function</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qowe.set_seed">
<span class="sig-name descname"><span class="pre">set_seed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qowe.set_seed" title="Link to this definition"></a></dt>
<dd><p>Integer for seeding of random number generation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>seed</strong><span class="classifier">int</span></dt><dd><p>seeds the generation of random parameters</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qowe.set_unitaries">
<span class="sig-name descname"><span class="pre">set_unitaries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unitaries</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#quop_mpi.Unitary" title="quop_mpi.Unitary.Unitary"><span class="pre">Unitary</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qowe.set_unitaries" title="Link to this definition"></a></dt>
<dd><p>Define the <a class="reference internal" href="glossary.html#term-ansatz-unitary"><span class="xref std std-term">ansatz unitary</span></a>.</p>
<blockquote>
<div><p><a class="reference internal" href="glossary.html#term-unitary"><span class="xref std std-term">Unitaries</span></a> are passed as a python list in order of
application from left to right.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>unitaries: list[unitary]</strong></dt><dd><p>list of <a class="reference internal" href="glossary.html#term-unitary"><span class="xref std std-term">unitaries</span></a> specifying the action of one
<a class="reference internal" href="glossary.html#term-ansatz-depth"><span class="xref std std-term">ansatz iteration</span></a></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.algorithm.multivariable.qowe.unset_sampling">
<span class="sig-name descname"><span class="pre">unset_sampling</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.algorithm.multivariable.qowe.unset_sampling" title="Link to this definition"></a></dt>
<dd><p>Revert to simulation using exact computation of the
<a class="reference internal" href="glossary.html#term-objective-function"><span class="xref std std-term">objective function</span></a>.</p>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="module-quop_mpi.observable">
<span id="observable"></span><h2>observable<a class="headerlink" href="#module-quop_mpi.observable" title="Link to this heading"></a></h2>
<p>Predefined <a class="reference internal" href="quop_functions.html#term-Observables-Function"><span class="xref std std-term">Observable Functions</span></a>.</p>
<p>See also: <a class="reference internal" href="#quop_mpi.Ansatz.set_observables" title="quop_mpi.Ansatz.set_observables"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quop_mpi.Ansatz.set_observables()</span></code></a>.</p>
<dl class="py function">
<dt class="sig sig-object py" id="quop_mpi.observable.array">
<span class="sig-prename descclassname"><span class="pre">quop_mpi.observable.</span></span><span class="sig-name descname"><span class="pre">array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">partition_table</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">MPI_COMM</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Intracomm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">array</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#quop_mpi.observable.array" title="Link to this definition"></a></dt>
<dd><p>Define <a class="reference internal" href="glossary.html#term-observables"><span class="xref std std-term">observables</span></a> with a NumPy ndarray.</p>
<p>An <a class="reference internal" href="quop_functions.html#term-Observables-Function"><span class="xref std std-term">Observables Function</span></a>. The <code class="docutils literal notranslate"><span class="pre">array</span></code> argument must be passed to
<a class="reference internal" href="#quop_mpi.Ansatz.set_observables" title="quop_mpi.Ansatz.set_observables"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quop_mpi.Ansatz.set_observables()</span></code></a> in a <a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> .</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>partition_table</strong><span class="classifier">list[int]</span></dt><dd><p>1-D array describing the global partitioning scheme, <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a> attribute</p>
</dd>
<dt><strong>MPI_COMM</strong><span class="classifier">Intracomm</span></dt><dd><p>MPI communicator, <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a> attribute</p>
</dd>
<dt><strong>array</strong><span class="classifier">Union[list[float], ndarray[float]]</span></dt><dd><p>a 1-D real array containing <a class="reference internal" href="glossary.html#term-system-size"><span class="xref std std-term">system size</span></a> observable values</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray[float64]</dt><dd><p><code class="docutils literal notranslate"><span class="pre">local_i</span></code> observable values with global index offset <code class="docutils literal notranslate"><span class="pre">local_i_offset</span></code> (see <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quop_mpi.Ansatz()</span></code></a>)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quop_mpi.observable.csv">
<span class="sig-prename descclassname"><span class="pre">quop_mpi.observable.</span></span><span class="sig-name descname"><span class="pre">csv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">partition_table</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">MPI_COMM</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Intracomm</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#quop_mpi.observable.csv" title="Link to this definition"></a></dt>
<dd><p>Load <a class="reference internal" href="glossary.html#term-observables"><span class="xref std std-term">observables</span></a> from a <code class="docutils literal notranslate"><span class="pre">*.csv</span></code> using <a class="reference external" href="https://pandas.pydata.org/">pandas</a>.</p>
<p>An <a class="reference internal" href="quop_functions.html#term-Observables-Function"><span class="xref std std-term">Observables Function</span></a>. The <code class="docutils literal notranslate"><span class="pre">filename</span></code> argument must be passed to
<a class="reference internal" href="#quop_mpi.Ansatz.set_observables" title="quop_mpi.Ansatz.set_observables"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quop_mpi.Ansatz.set_observables()</span></code></a> in a <a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a>. Additional
keyword arguments in the <code class="docutils literal notranslate"><span class="pre">FunctionDict</span></code> are passed to the <a class="reference external" href="https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html">pandas.read_csv</a> method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>partition_table</strong><span class="classifier">list[int]</span></dt><dd><p>1-D array describing the global partitioning scheme,
<a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a> attribute</p>
</dd>
<dt><strong>MPI_COMM</strong><span class="classifier">Intracomm</span></dt><dd><p>MPI communicator, <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a> attribute</p>
</dd>
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>path to a <code class="docutils literal notranslate"><span class="pre">*csv</span></code> file</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray[float64]</dt><dd><p><code class="docutils literal notranslate"><span class="pre">local_i</span></code> observable values with global index offset
<code class="docutils literal notranslate"><span class="pre">local_i_offset</span></code> (see <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quop_mpi.Ansatz()</span></code></a>)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quop_mpi.observable.hdf5">
<span class="sig-prename descclassname"><span class="pre">quop_mpi.observable.</span></span><span class="sig-name descname"><span class="pre">hdf5</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">partition_table</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">MPI_COMM</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Intracomm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dataset_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#quop_mpi.observable.hdf5" title="Link to this definition"></a></dt>
<dd><p>Load <a class="reference internal" href="glossary.html#term-observables"><span class="xref std std-term">observables</span></a> from a <code class="docutils literal notranslate"><span class="pre">*.h5</span></code> file using <a class="reference external" href="https://docs.h5py.org/en/latest/index.html">HDF5 for Python</a>.</p>
<p>An <a class="reference internal" href="quop_functions.html#term-Observables-Function"><span class="xref std std-term">Observables Function</span></a>. The <code class="docutils literal notranslate"><span class="pre">filename</span></code> and <code class="docutils literal notranslate"><span class="pre">dataset_name</span></code>
arguments must be passed to <a class="reference internal" href="#quop_mpi.Ansatz.set_observables" title="quop_mpi.Ansatz.set_observables"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quop_mpi.Ansatz.set_observables()</span></code></a> in a
<a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a>. Additional positional and keyword arguments in the
<code class="docutils literal notranslate"><span class="pre">FunctionDict</span></code> are passed to the <a class="reference external" href="https://docs.h5py.org/en/latest/high/file.html">h5py.File</a> method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>partition_table</strong><span class="classifier">list[int]</span></dt><dd><p>1-D array describing the global partitioning scheme,
<a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a> attribute</p>
</dd>
<dt><strong>MPI_COMM</strong><span class="classifier">Intracomm</span></dt><dd><p>MPI communicator, <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a> attribute</p>
</dd>
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>path to a <code class="docutils literal notranslate"><span class="pre">*.h5</span></code> file</p>
</dd>
<dt><strong>dataset_name</strong><span class="classifier">str</span></dt><dd><p>path to the dataset in <code class="docutils literal notranslate"><span class="pre">filename</span></code> containing an ndarray[float64] of
<a class="reference internal" href="glossary.html#term-system-size"><span class="xref std std-term">system size</span></a> observables.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray[float64]</dt><dd><p><code class="docutils literal notranslate"><span class="pre">local_i</span></code> observable values with global index offset
<code class="docutils literal notranslate"><span class="pre">local_i_offset</span></code> (see <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quop_mpi.Ansatz()</span></code></a>)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quop_mpi.observable.serial">
<span class="sig-prename descclassname"><span class="pre">quop_mpi.observable.</span></span><span class="sig-name descname"><span class="pre">serial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">partition_table</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">MPI_COMM</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Intracomm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#quop_mpi.observable.serial" title="Link to this definition"></a></dt>
<dd><p>Generate <a class="reference internal" href="glossary.html#term-observables"><span class="xref std std-term">observables</span></a> using a serial python function.</p>
<dl class="simple">
<dt>An <a class="reference internal" href="quop_functions.html#term-Observables-Function"><span class="xref std std-term">Observables Function</span></a>. The <code class="docutils literal notranslate"><span class="pre">function</span></code> argument must be passed to</dt><dd><p><a class="reference internal" href="#quop_mpi.Ansatz.set_observables" title="quop_mpi.Ansatz.set_observables"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quop_mpi.Ansatz.set_observables()</span></code></a> in a <a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a>. Additional</p>
</dd>
<dt>positional and keyword arguments in the <code class="docutils literal notranslate"><span class="pre">FunctionDict</span></code> are passed to</dt><dd><p><code class="docutils literal notranslate"><span class="pre">function</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>partition_table</strong><span class="classifier">list[int]</span></dt><dd><dl class="simple">
<dt>1-D array describing the global partitioning scheme, </dt><dd><p><a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a> attribute</p>
</dd>
</dl>
</dd>
<dt><strong>MPI_COMM</strong><span class="classifier">Intracomm</span></dt><dd><p>MPI communicator, <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a> attribute</p>
</dd>
<dt><strong>function</strong><span class="classifier">Callable</span></dt><dd><dl class="simple">
<dt>Python function returning a 1-D real array of <a class="reference internal" href="glossary.html#term-system-size"><span class="xref std std-term">system size</span></a> </dt><dd><p>observable values</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray[float64]</dt><dd><p><code class="docutils literal notranslate"><span class="pre">local_i</span></code> observable values with global index offset
<code class="docutils literal notranslate"><span class="pre">local_i_offset</span></code> (see <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quop_mpi.Ansatz()</span></code></a>)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-quop_mpi.observable.rand"></span><dl class="py function">
<dt class="sig sig-object py" id="quop_mpi.observable.rand.uniform">
<span class="sig-prename descclassname"><span class="pre">quop_mpi.observable.rand.</span></span><span class="sig-name descname"><span class="pre">uniform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">partition_table</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">MPI_COMM</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Intracomm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">low</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">high</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#quop_mpi.observable.rand.uniform" title="Link to this definition"></a></dt>
<dd><p>Generate random <a class="reference internal" href="glossary.html#term-observables"><span class="xref std std-term">observables</span></a> from a uniform distribution.</p>
<p>An <a class="reference internal" href="quop_functions.html#term-Observables-Function"><span class="xref std std-term">Observables Function</span></a>. The <code class="docutils literal notranslate"><span class="pre">low</span></code> and <code class="docutils literal notranslate"><span class="pre">high</span></code> arguments can be
passed to <a class="reference internal" href="#quop_mpi.Ansatz.set_observables" title="quop_mpi.Ansatz.set_observables"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quop_mpi.Ansatz.set_observables()</span></code></a> in a <a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>system_size</strong><span class="classifier">int</span></dt><dd><p>the <a class="reference internal" href="glossary.html#term-system-size"><span class="xref std std-term">size</span></a> of the simulated <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">system</span></a>,
class:<cite>quop_mpi.Ansatz</cite> attribute</p>
</dd>
<dt><strong>partition_table</strong><span class="classifier">list[int]</span></dt><dd><p>1-D array describing the global partitioning scheme,
<a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a> attribute</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int</span></dt><dd><p>sets the seed of the random number generator, <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a>
attribute</p>
</dd>
<dt><strong>MPI_COMM</strong><span class="classifier">Intracomm</span></dt><dd><p>MPI intracommunicator, <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a> attribute</p>
</dd>
<dt><strong>low</strong><span class="classifier">float, optional</span></dt><dd><p>lower bound of the generated observable values (inclusive), by default <code class="docutils literal notranslate"><span class="pre">0</span></code></p>
</dd>
<dt><strong>high</strong><span class="classifier">float, optional</span></dt><dd><p>upper bound of the genereated observable values (exclusive), by default <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>np.ndarray[float64]</dt><dd><p><code class="docutils literal notranslate"><span class="pre">local_i</span></code> observable values with global index offset
<code class="docutils literal notranslate"><span class="pre">local_i_offset</span></code> (see <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quop_mpi.Ansatz()</span></code></a>)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-quop_mpi.param">
<span id="param"></span><h2>param<a class="headerlink" href="#module-quop_mpi.param" title="Link to this heading"></a></h2>
<p>Predefined <a class="reference internal" href="quop_functions.html#term-Parameter-Function"><span class="xref std std-term">Parameter Functions</span></a>.</p>
<p>See <a class="reference internal" href="#quop_mpi.Unitary" title="quop_mpi.Unitary"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quop_mpi.Unitary()</span></code></a>.</p>
<span class="target" id="module-quop_mpi.param.rand"></span><dl class="py function">
<dt class="sig sig-object py" id="quop_mpi.param.rand.uniform">
<span class="sig-prename descclassname"><span class="pre">quop_mpi.param.rand.</span></span><span class="sig-name descname"><span class="pre">uniform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_params</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">low</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">high</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">6.283185307179586</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#quop_mpi.param.rand.uniform" title="Link to this definition"></a></dt>
<dd><p>Generate initial <a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational parameters</span></a> from a uniform
distribution.</p>
<p>The default <a class="reference internal" href="quop_functions.html#term-Parameter-Function"><span class="xref std std-term">Parameter Function</span></a> of the <a class="reference internal" href="#quop_mpi.Unitary" title="quop_mpi.Unitary"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Unitary</span></code></a>
class. User specified <code class="docutils literal notranslate"><span class="pre">low</span></code> and <code class="docutils literal notranslate"><span class="pre">high</span></code> values can be specified by
passing a corresponding:term:<cite>FunctionDict</cite> to on initialisation of a
<code class="docutils literal notranslate"><span class="pre">unitary</span></code> instance (see <a class="reference internal" href="#quop_mpi.Unitary" title="quop_mpi.Unitary"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quop_mpi.Unitary()</span></code></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n_params</strong><span class="classifier">int</span></dt><dd><p>total number of <a class="reference internal" href="glossary.html#term-unitary-parameter"><span class="xref std std-term">unitary</span></a> and
<a class="reference internal" href="glossary.html#term-operator-parameter"><span class="xref std std-term">operator</span></a> <a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational parameters</span></a>,
<a class="reference internal" href="#quop_mpi.Unitary" title="quop_mpi.Unitary"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Unitary</span></code></a> attribute</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int</span></dt><dd><p>seeds random number generation, <a class="reference internal" href="#quop_mpi.Unitary" title="quop_mpi.Unitary"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Unitary</span></code></a> attribute</p>
</dd>
<dt><strong>low</strong><span class="classifier">float, optional</span></dt><dd><p>lower bound of the generated variational parameters (inclusive), by
default <code class="docutils literal notranslate"><span class="pre">0</span></code></p>
</dd>
<dt><strong>high</strong><span class="classifier">float, optional</span></dt><dd><p>upper bound of the generated variational parameters (exclusive), by
default <code class="docutils literal notranslate"><span class="pre">2*pi</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray[float64]</dt><dd><p>a 1-D array of <code class="docutils literal notranslate"><span class="pre">n_params</span></code> variational parameters</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-quop_mpi.state">
<span id="state"></span><h2>state<a class="headerlink" href="#module-quop_mpi.state" title="Link to this heading"></a></h2>
<p>Predefined <a class="reference internal" href="quop_functions.html#term-Initial-State-Function"><span class="xref std std-term">Initial State Functions</span></a> .</p>
<p>See <a class="reference internal" href="#quop_mpi.Ansatz.set_initial_state" title="quop_mpi.Ansatz.set_initial_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_initial_state()</span></code></a>.</p>
<dl class="py function">
<dt class="sig sig-object py" id="quop_mpi.state.array">
<span class="sig-prename descclassname"><span class="pre">quop_mpi.state.</span></span><span class="sig-name descname"><span class="pre">array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">local_i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local_i_offset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">MPI_COMM</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Intracomm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.complex128</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.complex128</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#quop_mpi.state.array" title="Link to this definition"></a></dt>
<dd><p>Define the <a class="reference internal" href="glossary.html#term-initial-state"><span class="xref std std-term">initial state</span></a> using a Numpy array.</p>
<p>An <a class="reference internal" href="quop_functions.html#term-Initial-State-Function"><span class="xref std std-term">Initial State Function</span></a>. The <code class="docutils literal notranslate"><span class="pre">normalize</span></code> argument can be
specified by passing a <a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> to 
<a class="reference internal" href="#quop_mpi.Ansatz.set_initial_state" title="quop_mpi.Ansatz.set_initial_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_initial_state()</span></code></a> .</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>local_i</strong><span class="classifier">int</span></dt><dd><p>size of the local <a class="reference internal" href="glossary.html#term-system-state"><span class="xref std std-term">system state</span></a> partitions,
<a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a> attribute</p>
</dd>
<dt><strong>local_i_offset</strong><span class="classifier">int</span></dt><dd><p>global index offset of the local system state partitions,
<a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a> attribute</p>
</dd>
<dt><strong>MPI_COMM</strong><span class="classifier">Intracomm</span></dt><dd><p>MPI communicator of the <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVA</span></a> simulation,
<a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a> attribute</p>
</dd>
<dt><strong>state</strong><span class="classifier">ndarray[complex128]</span></dt><dd><p>A 1-D array of <a class="reference internal" href="glossary.html#term-system-size"><span class="xref std std-term">system size</span></a> initial state values</p>
</dd>
<dt><strong>normalize</strong><span class="classifier">bool, optional</span></dt><dd><p>wether to normalize <code class="docutils literal notranslate"><span class="pre">state</span></code>, by default True</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray[complex128]</dt><dd><p>1-D complex array of <code class="docutils literal notranslate"><span class="pre">local_i</span></code> <a class="reference internal" href="glossary.html#term-initial-state"><span class="xref std std-term">initial state</span></a> values with
global index offset <code class="docutils literal notranslate"><span class="pre">local_i_offset</span></code> (see <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a>)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quop_mpi.state.basis">
<span class="sig-prename descclassname"><span class="pre">quop_mpi.state.</span></span><span class="sig-name descname"><span class="pre">basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">local_i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local_i_offset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis_states</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.complex128</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#quop_mpi.state.basis" title="Link to this definition"></a></dt>
<dd><p>Generate an equal superposition over a subset of basis states.</p>
<p>An <a class="reference internal" href="quop_functions.html#term-Initial-State-Function"><span class="xref std std-term">Initial State Function</span></a>. The <code class="docutils literal notranslate"><span class="pre">basis_states</span></code> argument can be
specified by passing a <a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> to
<a class="reference internal" href="#quop_mpi.Ansatz.set_initial_state" title="quop_mpi.Ansatz.set_initial_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quop_mpi.Ansatz.set_initial_state()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>local_i</strong><span class="classifier">int</span></dt><dd><p>size of the local <a class="reference internal" href="glossary.html#term-system-state"><span class="xref std std-term">system state</span></a> partitions,
<a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a> attribute</p>
</dd>
<dt><strong>local_i_offset</strong><span class="classifier">int</span></dt><dd><p>global index offset of the local system state partitions,
<a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a> attribute</p>
</dd>
<dt><strong>basis_states</strong><span class="classifier">list[int], optional</span></dt><dd><p>global indexes specifying an equal superposition over a subset of
states, by default [0]</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray[complex128]</dt><dd><p>1-D complex array of <code class="docutils literal notranslate"><span class="pre">local_i</span></code> <a class="reference internal" href="glossary.html#term-initial-state"><span class="xref std std-term">initial state</span></a> values with
global index offset <code class="docutils literal notranslate"><span class="pre">local_i_offset</span></code> (see <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a> )</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quop_mpi.state.equal">
<span class="sig-prename descclassname"><span class="pre">quop_mpi.state.</span></span><span class="sig-name descname"><span class="pre">equal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local_i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.complex128</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#quop_mpi.state.equal" title="Link to this definition"></a></dt>
<dd><p>Generate an equal superposition over all <a class="reference internal" href="glossary.html#term-system-state"><span class="xref std std-term">system states</span></a>.</p>
<p>The default <a class="reference internal" href="quop_functions.html#term-Initial-State-Function"><span class="xref std std-term">Initial State Function</span></a> of the <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a>
class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>system_size</strong><span class="classifier">int</span></dt><dd><p>size of the simulated <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVA</span></a>, <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a> attribute</p>
</dd>
<dt><strong>local_i</strong><span class="classifier">int</span></dt><dd><p>size of the local <a class="reference internal" href="glossary.html#term-system-state"><span class="xref std std-term">system state</span></a> partitions, 
<a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a> attribute</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray[complex128]</dt><dd><p>1-D complex array of <code class="docutils literal notranslate"><span class="pre">local_i</span></code> <a class="reference internal" href="glossary.html#term-initial-state"><span class="xref std std-term">initial state</span></a> values with
global index offset <code class="docutils literal notranslate"><span class="pre">local_i_offset</span></code> (see <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a>)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quop_mpi.state.position_grid">
<span class="sig-prename descclassname"><span class="pre">quop_mpi.state.</span></span><span class="sig-name descname"><span class="pre">position_grid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alloc_local</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local_i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local_i_offset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">MPI_COMM</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Intracomm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ns</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deltas</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mins</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.complex128</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#quop_mpi.state.position_grid" title="Link to this definition"></a></dt>
<dd><p>Generate an <a class="reference internal" href="glossary.html#term-initial-state"><span class="xref std std-term">initial state</span></a> discrete Cartesian coordinates.</p>
<p>An <a class="reference internal" href="quop_functions.html#term-Observables-Function"><span class="xref std std-term">Observables Function</span></a>. Arguments <code class="docutils literal notranslate"><span class="pre">Ns</span></code>, <code class="docutils literal notranslate"><span class="pre">deltas</span></code>, <code class="docutils literal notranslate"><span class="pre">mins</span></code> and
<code class="docutils literal notranslate"><span class="pre">function</span></code> must be passed to <a class="reference internal" href="#quop_mpi.Ansatz.set_observables" title="quop_mpi.Ansatz.set_observables"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quop_mpi.Ansatz.set_observables()</span></code></a> in a
<a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">function</span></code> argument must take an <code class="docutils literal notranslate"><span class="pre">len(Ns)</span></code> -dimensional coordinate
and return the complex amplitude of the initial state at that coordinate.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">function</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">position_grid</span></code> generates a squeezed
Gaussian state with its mean situated at a randomly generated coordinate
that has a distance of at least <code class="docutils literal notranslate"><span class="pre">length</span> <span class="pre">*</span> <span class="pre">0.125</span></code> from the boundaries of
the grid (where <code class="docutils literal notranslate"><span class="pre">length</span></code> is the length in each coordinate).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>alloc_local</strong><span class="classifier">int</span></dt><dd><p>size of the array containing the local partition of the system,
<a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a> attribute</p>
</dd>
<dt><strong>local_i</strong><span class="classifier">int</span></dt><dd><p>number of initial state values in local partition of the 
<a class="reference internal" href="glossary.html#term-system-state"><span class="xref std std-term">system state</span></a>, <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a> attribute</p>
</dd>
<dt><strong>local_i_offset</strong><span class="classifier">int</span></dt><dd><p>global index offset of the local system state partition,
<a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a> attribute</p>
</dd>
<dt><strong>MPI_COMM</strong><span class="classifier">Intracomm</span></dt><dd><p>MPI communicator, <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a> attribute</p>
</dd>
<dt><strong>Ns</strong><span class="classifier">list[int]</span></dt><dd><p>number of grid points in each dimension of the Cartesian grid</p>
</dd>
<dt><strong>deltas</strong><span class="classifier">list[float]</span></dt><dd><p>step size in each coordinate</p>
</dd>
<dt><strong>mins</strong><span class="classifier">list[float]</span></dt><dd><p>minimum value in each coordinate</p>
</dd>
<dt><strong>function</strong><span class="classifier">Callable</span></dt><dd><p>a Python function returning the value of the initial state at each grid
point</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray[complex128]</dt><dd><p>1-D complex array of <code class="docutils literal notranslate"><span class="pre">local_i</span></code> <a class="reference internal" href="glossary.html#term-initial-state"><span class="xref std std-term">initial state</span></a> values with
global index offset <code class="docutils literal notranslate"><span class="pre">local_i_offset</span></code> (see <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a>)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quop_mpi.state.serial">
<span class="sig-prename descclassname"><span class="pre">quop_mpi.state.</span></span><span class="sig-name descname"><span class="pre">serial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">partition_table</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">MPI_COMM</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Intracomm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.complex128</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#quop_mpi.state.serial" title="Link to this definition"></a></dt>
<dd><p>Generate the <a class="reference internal" href="glossary.html#term-initial-state"><span class="xref std std-term">initial state</span></a> using a serial Python function.</p>
<p>An <a class="reference internal" href="quop_functions.html#term-Initial-State-Function"><span class="xref std std-term">Initial State Function</span></a>. The <code class="docutils literal notranslate"><span class="pre">function</span></code> argument must be
specified by passing a <a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> to
<a class="reference internal" href="#quop_mpi.Ansatz.set_initial_state" title="quop_mpi.Ansatz.set_initial_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_initial_state()</span></code></a>. Additional positional and keyword
arguments in the <code class="docutils literal notranslate"><span class="pre">FunctionDict</span></code> are passed to <code class="docutils literal notranslate"><span class="pre">function</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>partition_table</strong><span class="classifier">list[int]</span></dt><dd><p>1-D array describing the global partitioning scheme,
<a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a> attribute</p>
</dd>
<dt><strong>MPI_COMM</strong><span class="classifier">Intracomm</span></dt><dd><p>MPI communicator of the <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVA</span></a> simulation,
<a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a> attribute</p>
</dd>
<dt><strong>function</strong><span class="classifier">Callable</span></dt><dd><p>a Python function returning a 1-D complex array of <a class="reference internal" href="glossary.html#term-system-size"><span class="xref std std-term">system size</span></a>
initial state values</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray[complex128]</dt><dd><p>1-D complex array of <code class="docutils literal notranslate"><span class="pre">local_i</span></code> <a class="reference internal" href="glossary.html#term-initial-state"><span class="xref std std-term">initial state</span></a> values with
global index offset <code class="docutils literal notranslate"><span class="pre">local_i_offset</span></code> (see <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a>)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="meta">
<h2>meta<a class="headerlink" href="#meta" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="quop_mpi.meta.swarm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quop_mpi.meta.</span></span><span class="sig-name descname"><span class="pre">swarm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes_per_subcomm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">processes_per_node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxcomm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">MPI_COMM</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">COMM_WORLD</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">type</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.meta.swarm" title="Link to this definition"></a></dt>
<dd><p>Create and operate on a swarm of identical <code class="docutils literal notranslate"><span class="pre">Ansatz</span></code> instances.</p>
<p>Each <code class="docutils literal notranslate"><span class="pre">Ansatz</span></code> instance is associated with an MPI subcommunicator
such that they can carry out <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVA</span></a> simulation independently.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Ansatz</span></code> instance is initialised by the <code class="docutils literal notranslate"><span class="pre">swarm</span></code>
instance as,</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Ansatz</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">MPI_COMM</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nodes_per_subcomm</strong><span class="classifier">int</span></dt><dd><p>number of compute nodes associated with each <code class="docutils literal notranslate"><span class="pre">Ansatz</span></code>
subcommunicator, if <code class="docutils literal notranslate"><span class="pre">nodes_per_subcomm</span> <span class="pre">==</span> <span class="pre">1</span></code> create
<code class="docutils literal notranslate"><span class="pre">maxcomm</span></code> subcommunicators per available compute node.</p>
</dd>
<dt><strong>processes_per_node</strong><span class="classifier">int</span></dt><dd><p>number of MPI processes per compute node, must be the same for all nodes</p>
</dd>
<dt><strong>maxcomm</strong><span class="classifier">int</span></dt><dd><p>target number of <code class="docutils literal notranslate"><span class="pre">Ansatz</span></code> subcommunicators</p>
</dd>
<dt><strong>MPI_COMM</strong><span class="classifier">Intracomm</span></dt><dd><p>MPI communicator from which to create the <code class="docutils literal notranslate"><span class="pre">Ansatz</span></code>
subcommunicators</p>
</dd>
<dt><strong>alg</strong><span class="classifier">Ansatz</span></dt><dd><p>an <code class="docutils literal notranslate"><span class="pre">Ansatz</span></code>, <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a> or a predefined algorithm
(see <code class="xref py py-mod docutils literal notranslate"><span class="pre">quop_mpi.algorithm</span></code>)</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.meta.swarm.benchmark">
<span class="sig-name descname"><span class="pre">benchmark</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.meta.swarm.benchmark" title="Link to this definition"></a></dt>
<dd><p>Test <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVA</span></a> performance as a function of <a class="reference internal" href="glossary.html#term-ansatz-depth"><span class="xref std std-term">Ansatz Depth</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>args: list[Ans] or list[list[Any]]</strong></dt><dd><p>positional arguments for <code class="xref py py-meth docutils literal notranslate"><span class="pre">quop_mpi.ansatz.benchmark()</span></code>, or a
list of positional arguments specifying unique input for
<code class="xref py py-meth docutils literal notranslate"><span class="pre">quop_mpi.ansatz.benchmark()</span></code> for each <code class="docutils literal notranslate"><span class="pre">Ansatz</span></code>
instance.</p>
</dd>
<dt><strong>kwargs: dict</strong></dt><dd><p>keyword arguments for <code class="xref py py-meth docutils literal notranslate"><span class="pre">quop_mpi.ansatz.benchmark()</span></code>, or keywords
pointing to a list of positional arguments specifying unique input
for <code class="xref py py-meth docutils literal notranslate"><span class="pre">quop_mpi.ansatz.benchmark()</span></code> for each <code class="docutils literal notranslate"><span class="pre">Ansatz</span></code>
instance.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#quop_mpi.Ansatz.benchmark" title="quop_mpi.Ansatz.benchmark"><code class="xref py py-meth docutils literal notranslate"><span class="pre">benchmark()</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.meta.swarm.benchmark_swarm">
<span class="sig-name descname"><span class="pre">benchmark_swarm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ansatz_depths</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repeats</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param_persist</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_action</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'a'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_limit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logging</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suspend_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.meta.swarm.benchmark_swarm" title="Link to this definition"></a></dt>
<dd><p>Test <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVA</span></a> performance with increasing <a class="reference internal" href="glossary.html#term-ansatz-depth"><span class="xref std std-term">ansatz depth</span></a>
with repeats at each depth computed in parallel over the
<code class="docutils literal notranslate"><span class="pre">swarm</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ansatz_depths</strong><span class="classifier">Iterable[int]</span></dt><dd><p>simulated <a class="reference internal" href="glossary.html#term-ansatz-depth"><span class="xref std std-term">ansatz depths</span></a></p>
</dd>
<dt><strong>repeats</strong><span class="classifier">int</span></dt><dd><p>number of repeats at each ansatz depth</p>
</dd>
<dt><strong>basename</strong><span class="classifier">str</span></dt><dd><p>path to directory in which to write simulation results and logs, by
default <code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
<dt><strong>param_persist</strong><span class="classifier">bool, optional</span></dt><dd><p>if <code class="docutils literal notranslate"><span class="pre">True</span></code> the <a class="reference internal" href="glossary.html#term-optimiser"><span class="xref std std-term">optimised</span></a>
<a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational parameter</span></a> values which
achieved the lowest <a class="reference internal" href="glossary.html#term-objective-function"><span class="xref std std-term">objective function</span></a> value  for all
repeats at <code class="docutils literal notranslate"><span class="pre">ansatz_depth</span></code> will be used as starting
parameters for the first <code class="docutils literal notranslate"><span class="pre">ansatz_depth</span> <span class="pre">*</span> <span class="pre">total_params</span></code> at
<code class="docutils literal notranslate"><span class="pre">ansatz_depth</span> <span class="pre">+=</span> <span class="pre">1</span></code>, by default <code class="docutils literal notranslate"><span class="pre">True</span></code></p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool, optional</span></dt><dd><p>if <code class="docutils literal notranslate"><span class="pre">True</span></code>, print current the <a class="reference internal" href="glossary.html#term-ansatz-depth"><span class="xref std std-term">ansatz depth</span></a>, repeat
number and <a class="reference internal" href="glossary.html#term-optimiser"><span class="xref std std-term">optimisation</span></a> results, by default
<code class="docutils literal notranslate"><span class="pre">True</span></code></p>
</dd>
<dt><strong>save_action</strong><span class="classifier">{‘a’, ‘w’}</span></dt><dd><p>‘a’ to append, ‘w’ to (over)write, by default “a”</p>
</dd>
<dt><strong>time_limit</strong><span class="classifier">float, optional</span></dt><dd><p>time limit in seconds, program will suspend if the time remaining is
less than the time taken by the last simulation, by default
<code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
<dt><strong>logging</strong><span class="classifier">bool, optional</span></dt><dd><p>write simulation results to log files, by default <code class="docutils literal notranslate"><span class="pre">True</span></code></p>
</dd>
<dt><strong>suspend_path</strong><span class="classifier">str, optional</span></dt><dd><p>path to directory in which to write suspend data, by default
<code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>list[dict]</dt><dd><p>optimisation results ordered by ansatz depth</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.meta.swarm.execute_swarm">
<span class="sig-name descname"><span class="pre">execute_swarm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">param_lists</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.float64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h5_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_action</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'a'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_limit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suspend_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.meta.swarm.execute_swarm" title="Link to this definition"></a></dt>
<dd><p>Parallel simulation of <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVAs</span></a> over a set of initial
<a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational parameters</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>param_lists</strong><span class="classifier">list[np.ndarray[np.float64]]</span></dt><dd><p>list of 1-D real arrays containing initial <a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational
parameters</span></a></p>
</dd>
<dt><strong>basename</strong><span class="classifier">str</span></dt><dd><p>folder in which to store simulation results and suspend data unless
otherwise specified, by default <code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
<dt><strong>log_path</strong><span class="classifier">str, optional</span></dt><dd><p>folder in which to write simulation log files, by default
<code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
<dt><strong>h5_path</strong><span class="classifier">str, optional</span></dt><dd><p>folder in which to write simulation results, by default
<code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
<dt><strong>labels</strong><span class="classifier">str or list[str], optional</span></dt><dd><p>labels(s) for each simulation, by default <code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
<dt><strong>save_action</strong><span class="classifier">{“a”, “w”}</span></dt><dd><p>“a” to append “w” to (over)write, by default <code class="docutils literal notranslate"><span class="pre">&quot;a&quot;</span></code></p>
</dd>
<dt><strong>time_limit</strong><span class="classifier">float, optional</span></dt><dd><p>suspend if the time remaining is less than the time taken by the
last <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVA</span></a> simulation, by default <code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool, optional</span></dt><dd><p>print the simulation results and simulation progress, by default
<code class="docutils literal notranslate"><span class="pre">True</span></code></p>
</dd>
<dt><strong>suspend_path</strong><span class="classifier">str, optional</span></dt><dd><p>folder in which to store suspend data, by default <code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>dict</dt><dd><p>a dictionary of optimisation results with keys
<code class="docutils literal notranslate"><span class="pre">str(params_list[i])</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.meta.swarm.get_optimal_result">
<span class="sig-name descname"><span class="pre">get_optimal_result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#quop_mpi.meta.swarm.get_optimal_result" title="Link to this definition"></a></dt>
<dd><p>Retrieve the result with the lowest <a class="reference internal" href="glossary.html#term-objective-function"><span class="xref std std-term">objective function</span></a> value
out of the last set of simulations executed by the <code class="docutils literal notranslate"><span class="pre">swarm</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>dict</dt><dd><p>simulation result</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.meta.swarm.save">
<span class="sig-name descname"><span class="pre">save</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.meta.swarm.save" title="Link to this definition"></a></dt>
<dd><p>Save simulation results.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>args:</strong></dt><dd><p>positional arguments for <code class="xref py py-meth docutils literal notranslate"><span class="pre">quop_mpi.ansatz.save()</span></code>, or a list of
positional arguments specifying unique input for
<code class="xref py py-meth docutils literal notranslate"><span class="pre">quop_mpi.ansatz.save()</span></code> for each <code class="docutils literal notranslate"><span class="pre">Ansatz</span></code> instance.</p>
</dd>
<dt><strong>kwargs:</strong></dt><dd><p>keyword arguments for <code class="xref py py-meth docutils literal notranslate"><span class="pre">quop_mpi.ansatz.save()</span></code>, or keywords
pointing to a list of positional arguments specifying unique input
for <code class="xref py py-meth docutils literal notranslate"><span class="pre">quop_mpi.ansatz.save()</span></code> for each <code class="docutils literal notranslate"><span class="pre">Ansatz</span></code>
instance.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#quop_mpi.Ansatz.save" title="quop_mpi.Ansatz.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.meta.swarm.set_log">
<span class="sig-name descname"><span class="pre">set_log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.meta.swarm.set_log" title="Link to this definition"></a></dt>
<dd><p>Log simulation information.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>args: list[Any] or list[list[Any]]</strong></dt><dd><p>positional arguments for <code class="xref py py-meth docutils literal notranslate"><span class="pre">quop_mpi.ansatz.set_log()</span></code>, or a list
of positional arguments specifying unique input for
<code class="xref py py-meth docutils literal notranslate"><span class="pre">quop_mpi.ansatz.set_log()</span></code> for each <code class="docutils literal notranslate"><span class="pre">Ansatz</span></code> instance.</p>
</dd>
<dt><strong>kwargs: dict</strong></dt><dd><p>keyword arguments for <code class="xref py py-meth docutils literal notranslate"><span class="pre">quop_mpi.ansatz.set_log()</span></code>, or keywords
pointing to a list of positional arguments specifying unique input
for <code class="xref py py-meth docutils literal notranslate"><span class="pre">quop_mpi.ansatz.set_log()</span></code> for each <code class="docutils literal notranslate"><span class="pre">Ansatz</span></code>
instance.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#quop_mpi.Ansatz.set_log" title="quop_mpi.Ansatz.set_log"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_log()</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.meta.swarm.set_unitaries">
<span class="sig-name descname"><span class="pre">set_unitaries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unitaries</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#quop_mpi.Unitary" title="quop_mpi.Unitary.Unitary"><span class="pre">Unitary</span></a><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#quop_mpi.Unitary" title="quop_mpi.Unitary.Unitary"><span class="pre">Unitary</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.meta.swarm.set_unitaries" title="Link to this definition"></a></dt>
<dd><p>Set the unitaries of an <code class="docutils literal notranslate"><span class="pre">Ansatz</span></code> swarm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>unitaries :list[Unitary] or list[list[Unitary]]</strong></dt><dd><p>a list of <code class="docutils literal notranslate"><span class="pre">unitary</span></code> instances (broadcast to all swarm instances)
or a list of <code class="docutils literal notranslate"><span class="pre">unitary</span></code> instances for each <code class="docutils literal notranslate"><span class="pre">Ansatz</span></code> instance in
the <code class="docutils literal notranslate"><span class="pre">swarm</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>RuntimeError</dt><dd><p>if <code class="docutils literal notranslate"><span class="pre">unitaries`is</span> <span class="pre">a</span> <span class="pre">list</span> <span class="pre">of</span> <span class="pre">lists</span> <span class="pre">that</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">equal</span> <span class="pre">to</span> <span class="pre">the</span>
<span class="pre">:literal:`swarm</span></code> size</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-quop_mpi.propagator">
<span id="propagator"></span><h2>propagator<a class="headerlink" href="#module-quop_mpi.propagator" title="Link to this heading"></a></h2>
<p>Predefined <code class="docutils literal notranslate"><span class="pre">unitary</span></code> classes for simulation of the action of <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVA</span></a>
<a class="reference internal" href="glossary.html#term-Phase-Shift-Unitary"><span class="xref std std-term">phase-shift</span></a> and <a class="reference internal" href="glossary.html#term-Mixing-Unitary"><span class="xref std std-term">mixing</span></a>
unitaries with compatible <a class="reference internal" href="quop_functions.html#term-Operator-Function"><span class="xref std std-term">Operator Functions</span></a>.</p>
<section id="module-quop_mpi.propagator.circulant">
<span id="circulant"></span><h3>circulant<a class="headerlink" href="#module-quop_mpi.propagator.circulant" title="Link to this heading"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="quop_mpi.propagator.circulant.unitary">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quop_mpi.propagator.circulant.</span></span><span class="sig-name descname"><span class="pre">unitary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.propagator.circulant.unitary" title="Link to this definition"></a></dt>
<dd></dd></dl>

<section id="module-quop_mpi.propagator.circulant.operator">
<span id="operators"></span><h4>operators<a class="headerlink" href="#module-quop_mpi.propagator.circulant.operator" title="Link to this heading"></a></h4>
<p>Predefined <a class="reference internal" href="quop_functions.html#term-Operator-Function"><span class="xref std std-term">Operator Functions</span></a> for
<a class="reference internal" href="#quop_mpi.propagator.circulant.unitary" title="quop_mpi.propagator.circulant.unitary"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.propagator.circulant.unitary</span></code></a>.</p>
<p>An Operator Function for <code class="docutils literal notranslate"><span class="pre">'circulant'</span></code> <code class="docutils literal notranslate"><span class="pre">unitary</span></code> instances return a
<code class="docutils literal notranslate"><span class="pre">local_i</span></code> sized partition of the <a class="reference internal" href="glossary.html#term-operator"><span class="xref std std-term">operator</span></a> eigenvalues with global index offset
<code class="docutils literal notranslate"><span class="pre">local_i_offset</span></code>.</p>
<dl class="py function">
<dt class="sig sig-object py" id="quop_mpi.propagator.circulant.operator.complete">
<span class="sig-prename descclassname"><span class="pre">quop_mpi.propagator.circulant.operator.</span></span><span class="sig-name descname"><span class="pre">complete</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#quop_mpi.propagator.circulant.operator.complete" title="Link to this definition"></a></dt>
<dd><p>Generate a parallel partition of the eigenvalues of a complete
circulant graph with edge weightings <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
<p>An <a class="reference internal" href="quop_functions.html#term-Operator-Function"><span class="xref std std-term">Operator Function</span></a> associated with
<a class="reference internal" href="#quop_mpi.propagator.circulant.unitary" title="quop_mpi.propagator.circulant.unitary"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.propagator.circulant.unitary</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>system_size</strong><span class="classifier">int</span></dt><dd><p>the size of the simulated <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVA</span></a></p>
</dd>
<dt><strong>local_i</strong><span class="classifier">int</span></dt><dd><p>size of the local <a class="reference internal" href="glossary.html#term-system-state"><span class="xref std std-term">system state</span></a> partitions,
<a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a> attribute</p>
</dd>
<dt><strong>local_i_offset</strong><span class="classifier">int</span></dt><dd><p>global index offset of the local system state partitions,
<a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a> attribute</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray[complex128]</dt><dd><p>1-D complex array of <code class="docutils literal notranslate"><span class="pre">local_i</span></code> eigenvalues with
global index offset <code class="docutils literal notranslate"><span class="pre">local_i_offset</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quop_mpi.propagator.circulant.operator.graph">
<span class="sig-prename descclassname"><span class="pre">quop_mpi.propagator.circulant.operator.</span></span><span class="sig-name descname"><span class="pre">graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#quop_mpi.propagator.circulant.operator.graph" title="Link to this definition"></a></dt>
<dd><p>Generate the eigenvalues of the i-th symmetric circulant graph with
edge weightings <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
<p>An <a class="reference internal" href="quop_functions.html#term-Operator-Function"><span class="xref std std-term">Operator Function</span></a> associated with
<a class="reference internal" href="#quop_mpi.propagator.circulant.unitary" title="quop_mpi.propagator.circulant.unitary"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.propagator.circulant.unitary</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>system_size</strong><span class="classifier">int</span></dt><dd><p>the size of the simulated <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVA</span></a></p>
</dd>
<dt><strong>local_i</strong><span class="classifier">int</span></dt><dd><p>size of the local <a class="reference internal" href="glossary.html#term-system-state"><span class="xref std std-term">system state</span></a> partitions,
<a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a> attribute</p>
</dd>
<dt><strong>local_i_offset</strong><span class="classifier">int</span></dt><dd><p>global index offset of the local system state partitions,
<a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a> attribute</p>
</dd>
<dt><strong>i</strong><span class="classifier">int, optional</span></dt><dd><p>index of the graph (ordered by vertex degree), <code class="docutils literal notranslate"><span class="pre">1</span></code> corresponds to a
cycle graph and <code class="docutils literal notranslate"><span class="pre">system_size</span> <span class="pre">//</span> <span class="pre">2</span> <span class="pre">+</span> <span class="pre">1</span></code> to a complete graph, by default
<code class="docutils literal notranslate"><span class="pre">1</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray[complex128]</dt><dd><p>1-D complex array of <code class="docutils literal notranslate"><span class="pre">local_i</span></code> eigenvalues with global index offset
<code class="docutils literal notranslate"><span class="pre">local_i_offset</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
</section>
<section id="module-quop_mpi.propagator.diagonal">
<span id="diagonal"></span><h3>diagonal<a class="headerlink" href="#module-quop_mpi.propagator.diagonal" title="Link to this heading"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="quop_mpi.propagator.diagonal.unitary">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quop_mpi.propagator.diagonal.</span></span><span class="sig-name descname"><span class="pre">unitary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.propagator.diagonal.unitary" title="Link to this definition"></a></dt>
<dd><p>Compute the action of a <a class="reference internal" href="glossary.html#term-Mixing-Unitary"><span class="xref std std-term">mixing unitary</span></a> with a phase_shift
<a class="reference internal" href="glossary.html#term-operator"><span class="xref std std-term">operator</span></a> or a sequence of mixing-unitaries with phase_shift
operators (see the <code class="docutils literal notranslate"><span class="pre">unitary_n_params</span></code> attribute below).</p>
<p><strong>Inheritance Diagram:</strong></p>
<blockquote>
<div><div class="graphviz"><img src="_images/graphviz-f2be5656394a0471ede9fe3d96bf8000bc627002.png" alt="digraph &quot;sphinx-ext-graphviz&quot; {
    rankdir=&quot;LR&quot;;
    node [fontsize=&quot;10&quot;];
    Unitary[label=&quot;quop_mpi.Unitary&quot;, shape=&quot;rectangle&quot;];
    unitary[label=&quot;quop_mpi.propagator.phase_shift.unitary&quot;, shape=&quot;rectangle&quot;];

    Unitary -&gt; unitary;
}" class="graphviz" /></div>
</div></blockquote>
<p>See <a class="reference internal" href="#quop_mpi.Unitary" title="quop_mpi.Unitary"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Unitary</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>unitary_type</strong></dt><dd><p><code class="docutils literal notranslate"><span class="pre">'phase_shift'</span></code></p>
</dd>
<dt><strong>planner</strong></dt><dd><p><code class="docutils literal notranslate"><span class="pre">false</span></code></p>
</dd>
<dt><strong>unitary_n_params</strong></dt><dd><p>Set on initialisation to <code class="docutils literal notranslate"><span class="pre">1</span></code> or more. If <code class="docutils literal notranslate"><span class="pre">unitary_n_parameters</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>,
the <a class="reference internal" href="quop_functions.html#term-Operator-Function"><span class="xref std std-term">Operator Function</span></a> must return a <code class="docutils literal notranslate"><span class="pre">list[csr_matrix]</span></code> of
length <code class="docutils literal notranslate"><span class="pre">unitary_n_parameters</span></code> containing <code class="docutils literal notranslate"><span class="pre">csr_matrix</span></code> partitions of
of <code class="docutils literal notranslate"><span class="pre">local_i</span></code> rows.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.propagator.diagonal.unitary.propagate">
<span class="sig-name descname"><span class="pre">propagate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gammas</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.propagator.diagonal.unitary.propagate" title="Link to this definition"></a></dt>
<dd><p>Simulation of the action of a :term`unitary`.</p>
<p>When implemented, <code class="docutils literal notranslate"><span class="pre">propagate</span></code> contains a call to a method (typically a
contained in a complied Python extension module) that takes the class
attributes <code class="docutils literal notranslate"><span class="pre">initial_state</span></code>, <code class="docutils literal notranslate"><span class="pre">final_state</span></code> and <code class="docutils literal notranslate"><span class="pre">MPI_COMM</span></code>, together
with attributes describing the parallel partitioning scheme and
<a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational parameters</span></a> <code class="docutils literal notranslate"><span class="pre">x</span></code>, as input. The action of the unitary
is computed in MPI parallel, with the computed result written to
<code class="docutils literal notranslate"><span class="pre">final_state</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Not implemented by the base <code class="docutils literal notranslate"><span class="pre">Unitary</span></code> class.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">ndarray[float64]</span></dt><dd><p>a 1-D real array of <code class="docutils literal notranslate"><span class="pre">n_params</span></code> <a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational parameters</span></a></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">propagate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>

    <span class="n">external_propagator</span><span class="p">(</span>
        <span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition_table</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_state</span><span class="p">,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final_state</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">MPI_COMM</span> <span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<section id="id33">
<h4>operators<a class="headerlink" href="#id33" title="Link to this heading"></a></h4>
<p id="module-quop_mpi.propagator.diagonal.operator">Predefined <a class="reference internal" href="quop_functions.html#term-Operator-Function"><span class="xref std std-term">Operator Functions</span></a> and related utility
for <a class="reference internal" href="#quop_mpi.propagator.diagonal.unitary" title="quop_mpi.propagator.diagonal.unitary"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.propagator.diagonal.unitary</span></code></a>.</p>
<p>An Operator Function for <code class="docutils literal notranslate"><span class="pre">'diagonal'</span></code> <code class="docutils literal notranslate"><span class="pre">unitary</span></code> instances returns an
<code class="docutils literal notranslate"><span class="pre">ndarray[float64]</span></code> of size <code class="docutils literal notranslate"><span class="pre">local_i</span></code>, or a <code class="docutils literal notranslate"><span class="pre">list[ndarray[float64]]</span></code> with
<code class="docutils literal notranslate"><span class="pre">local_i</span></code> sized elements, which correspond to partition(s) of diagonal
<a class="reference internal" href="glossary.html#term-operator"><span class="xref std std-term">operator(s)</span></a> with global index offset <code class="docutils literal notranslate"><span class="pre">local_i_offset</span></code>.</p>
<p>If the Operator function returns <code class="docutils literal notranslate"><span class="pre">list[ndarray[float64]]</span></code>, the <code class="docutils literal notranslate"><span class="pre">unitary</span></code>
instance must be initialised with <code class="docutils literal notranslate"><span class="pre">unitary_n_parameters</span></code> equal to the length
of returned list. The resulting <code class="docutils literal notranslate"><span class="pre">unitary</span></code> is then equivalent to a sequence of
<a class="reference internal" href="glossary.html#term-Phase-Shift-Unitary"><span class="xref std std-term">phase-shift unitaries</span></a> with independently
parameterised <a class="reference internal" href="glossary.html#term-unitary-parameter"><span class="xref std std-term">unitary parameters</span></a>.</p>
<dl class="py function">
<dt class="sig sig-object py" id="quop_mpi.propagator.diagonal.operator.array">
<span class="sig-prename descclassname"><span class="pre">quop_mpi.propagator.diagonal.operator.</span></span><span class="sig-name descname"><span class="pre">array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">partition_table</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">MPI_COMM</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Intracomm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">array</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.float64</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#quop_mpi.propagator.diagonal.operator.array" title="Link to this definition"></a></dt>
<dd><p>Define the diagonal of the <a class="reference internal" href="glossary.html#term-Phase-Shift-Unitary"><span class="xref std std-term">phase-shift unitary</span></a> using a Numpy
array.</p>
<p>An <a class="reference internal" href="quop_functions.html#term-Operator-Function"><span class="xref std std-term">Operator Function</span></a> for the
<code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.propagate.diagonal.unitary</span></code> class.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For memory efficiency, <code class="docutils literal notranslate"><span class="pre">array</span></code> can be present as an <code class="docutils literal notranslate"><span class="pre">ndarray[float64]</span></code> at 
<code class="docutils literal notranslate"><span class="pre">MPI_COMM.rank</span> <span class="pre">==</span> <span class="pre">0</span></code> only and <code class="docutils literal notranslate"><span class="pre">None</span></code> at all other ranks in <code class="docutils literal notranslate"><span class="pre">MPI_COMM</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>partition_table</strong><span class="classifier">list[int]</span></dt><dd><p>describes the parallel partitioning scheme, <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a>
attribute</p>
</dd>
<dt><strong>MPI_COMM</strong><span class="classifier">Intracomm</span></dt><dd><p>MPI communicator, <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a> attribute</p>
</dd>
<dt><strong>array</strong><span class="classifier">np.ndarray[np.float64]</span></dt><dd><p>a 1-D real array of size <a class="reference internal" href="glossary.html#term-system-size"><span class="xref std std-term">system size</span></a></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray[float64]</dt><dd><p>a 1-D real array containing <code class="docutils literal notranslate"><span class="pre">local_i</span></code> elements of the operator
diagonal with global index offset <code class="docutils literal notranslate"><span class="pre">local_i_offset</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quop_mpi.propagator.diagonal.operator.cartesian">
<span class="sig-prename descclassname"><span class="pre">quop_mpi.propagator.diagonal.operator.</span></span><span class="sig-name descname"><span class="pre">cartesian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local_i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local_i_offset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ns</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deltas</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mins</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#quop_mpi.propagator.diagonal.operator.cartesian" title="Link to this definition"></a></dt>
<dd><p>TODO:UPDATE Generate the diagonal of a <a class="reference internal" href="glossary.html#term-Phase-Shift-Unitary"><span class="xref std std-term">phase-shift unitary</span></a> <a class="reference internal" href="glossary.html#term-operator"><span class="xref std std-term">operator</span></a>
using a Python function defined in discrete Cartesian coordinates.</p>
<p>An <a class="reference internal" href="quop_functions.html#term-Observables-Function"><span class="xref std std-term">Observables Function</span></a>. Depending on wether <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVA</span></a> simulation
is defined using the <code class="docutils literal notranslate"><span class="pre">Ansatz</span></code> class directly or with a predefined
<code class="docutils literal notranslate"><span class="pre">Ansatz</span></code> subclass from the <code class="docutils literal notranslate"><span class="pre">algorithm</span></code> submodule, the following
arguments must be defined in a corresponding <a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> on
initialisation of the <code class="docutils literal notranslate"><span class="pre">unitary</span></code> instance:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a>: <code class="docutils literal notranslate"><span class="pre">Ns</span></code>, <code class="docutils literal notranslate"><span class="pre">deltas</span></code>, <code class="docutils literal notranslate"><span class="pre">mins</span></code> and <code class="docutils literal notranslate"><span class="pre">function</span></code></p></li>
<li><p>algorithms in <a class="reference internal" href="#module-quop_mpi.algorithm.combinatorial" title="quop_mpi.algorithm.combinatorial"><code class="xref py py-mod docutils literal notranslate"><span class="pre">quop_mpi.algorithm.combinatorial</span></code></a>: <code class="docutils literal notranslate"><span class="pre">Ns</span></code>, <code class="docutils literal notranslate"><span class="pre">deltas</span></code>, <code class="docutils literal notranslate"><span class="pre">mins</span></code> and <code class="docutils literal notranslate"><span class="pre">function</span></code></p></li>
<li><p><a class="reference internal" href="#quop_mpi.algorithm.multivariable.qmoa" title="quop_mpi.algorithm.multivariable.qmoa"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.algorithm.multivariable.qmoa</span></code></a>: <code class="docutils literal notranslate"><span class="pre">deltas</span></code>, <code class="docutils literal notranslate"><span class="pre">mins</span></code> and <code class="docutils literal notranslate"><span class="pre">function</span></code></p></li>
<li><p><a class="reference internal" href="#quop_mpi.algorithm.multivariable.qowe" title="quop_mpi.algorithm.multivariable.qowe"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.algorithm.multivariable.qowe</span></code></a>: <code class="docutils literal notranslate"><span class="pre">function</span></code></p></li>
</ul>
</div></blockquote>
<p>Additional positional and keyword arguments in the <code class="docutils literal notranslate"><span class="pre">FunctionDict</span></code> are
passed to <code class="docutils literal notranslate"><span class="pre">function</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">function</span></code> argument must conform to the signature,</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">function</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">[</span><span class="n">float64</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">*</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">x</span></code> is a 1-D array containing a <code class="docutils literal notranslate"><span class="pre">len(Ns)</span></code> -dimensional grid
point.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>system_size</strong><span class="classifier">int</span></dt><dd><p>size of the simulated QVA</p>
</dd>
<dt><strong>local_i</strong><span class="classifier">int</span></dt><dd><p>size of the local <a class="reference internal" href="glossary.html#term-system-state"><span class="xref std std-term">system state</span></a> partition,
<a class="reference internal" href="#quop_mpi.Unitary" title="quop_mpi.Unitary"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Unitary</span></code></a> attribute</p>
</dd>
<dt><strong>local_i_offset</strong><span class="classifier">int</span></dt><dd><p>global index offset of the local system state partition,
<a class="reference internal" href="#quop_mpi.Unitary" title="quop_mpi.Unitary"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Unitary</span></code></a> attribute</p>
</dd>
<dt><strong>Ns</strong><span class="classifier">list[int]</span></dt><dd><p>the number of qubits assigned to each dimension of the cartesian grid
such that there is <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">**</span> <span class="pre">Ns[d]</span></code> grid points per dimension <code class="docutils literal notranslate"><span class="pre">d</span></code></p>
</dd>
<dt><strong>deltas</strong><span class="classifier">list[float]</span></dt><dd><p>step size in each Cartesian coordinate</p>
</dd>
<dt><strong>mins</strong><span class="classifier">list[float]</span></dt><dd><p>lower bound of each Cartesian coordinate</p>
</dd>
<dt><strong>function</strong><span class="classifier">Callable</span></dt><dd><p>a Python function that takes a list of <code class="docutils literal notranslate"><span class="pre">len(Ns)</span></code> real coordinate
values and returns a <code class="docutils literal notranslate"><span class="pre">float</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray[float64]</dt><dd><p>a 1-D real array containing <code class="docutils literal notranslate"><span class="pre">local_i</span></code> elements of the operator
diagonal with global index offset <code class="docutils literal notranslate"><span class="pre">local_i_offset</span></code></p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#quop_mpi.propagator.diagonal.operator.setup_cartesian" title="quop_mpi.propagator.diagonal.operator.setup_cartesian"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setup_cartesian</span></code></a></dt><dd><p>compute <code class="docutils literal notranslate"><span class="pre">deltas</span></code> and <code class="docutils literal notranslate"><span class="pre">mins</span></code></p>
</dd>
<dt><a class="reference internal" href="#quop_mpi.propagator.diagonal.operator.cartesian_scaled" title="quop_mpi.propagator.diagonal.operator.cartesian_scaled"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cartesian_scaled</span></code></a></dt><dd><p>alternative to <code class="docutils literal notranslate"><span class="pre">cartesian</span></code>, scales <code class="docutils literal notranslate"><span class="pre">function</span></code> between <code class="docutils literal notranslate"><span class="pre">0</span></code> and an upper bound.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quop_mpi.propagator.diagonal.operator.cartesian_scaled">
<span class="sig-prename descclassname"><span class="pre">quop_mpi.propagator.diagonal.operator.</span></span><span class="sig-name descname"><span class="pre">cartesian_scaled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local_i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local_i_offset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">MPI_COMM</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Intracomm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ns</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deltas</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mins</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#quop_mpi.propagator.diagonal.operator.cartesian_scaled" title="Link to this definition"></a></dt>
<dd><p>Generate the diagonal of a <a class="reference internal" href="glossary.html#term-Phase-Shift-Unitary"><span class="xref std std-term">phase-shift unitary</span></a> <a class="reference internal" href="glossary.html#term-operator"><span class="xref std std-term">operator</span></a>
using a Python function defined in discrete Cartesian coordinates with the
function scaled between <code class="docutils literal notranslate"><span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">coeff</span></code>.</p>
<p>An <a class="reference internal" href="quop_functions.html#term-Observables-Function"><span class="xref std std-term">Observables Function</span></a>. Depending on wether <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVA</span></a> simulation
is defined using the <code class="docutils literal notranslate"><span class="pre">Ansatz</span></code> class directly or with a predefined
<code class="docutils literal notranslate"><span class="pre">Ansatz</span></code> subclass from the <code class="docutils literal notranslate"><span class="pre">algorithm</span></code> submodule, the following
arguments must be defined in a corresponding <a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> on
initialisation of the <code class="docutils literal notranslate"><span class="pre">unitary</span></code> instance:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a>: <code class="docutils literal notranslate"><span class="pre">Ns</span></code>, <code class="docutils literal notranslate"><span class="pre">deltas</span></code>, <code class="docutils literal notranslate"><span class="pre">mins</span></code>, <code class="docutils literal notranslate"><span class="pre">function</span></code> and <code class="docutils literal notranslate"><span class="pre">coeff</span></code></p></li>
<li><p>algorithms in <a class="reference internal" href="#module-quop_mpi.algorithm.combinatorial" title="quop_mpi.algorithm.combinatorial"><code class="xref py py-mod docutils literal notranslate"><span class="pre">quop_mpi.algorithm.combinatorial</span></code></a>: <code class="docutils literal notranslate"><span class="pre">Ns</span></code>, <code class="docutils literal notranslate"><span class="pre">deltas</span></code>, <code class="docutils literal notranslate"><span class="pre">mins</span></code>, <code class="docutils literal notranslate"><span class="pre">function</span></code> and <code class="docutils literal notranslate"><span class="pre">coeff</span></code></p></li>
<li><p><a class="reference internal" href="#quop_mpi.algorithm.multivariable.qmoa" title="quop_mpi.algorithm.multivariable.qmoa"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.algorithm.multivariable.qmoa</span></code></a>: <code class="docutils literal notranslate"><span class="pre">deltas</span></code>, <code class="docutils literal notranslate"><span class="pre">mins</span></code>, <code class="docutils literal notranslate"><span class="pre">function</span></code> and <code class="docutils literal notranslate"><span class="pre">coeff</span></code></p></li>
<li><p><a class="reference internal" href="#quop_mpi.algorithm.multivariable.qowe" title="quop_mpi.algorithm.multivariable.qowe"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.algorithm.multivariable.qowe</span></code></a>: <code class="docutils literal notranslate"><span class="pre">function</span></code> and <code class="docutils literal notranslate"><span class="pre">coeff</span></code></p></li>
</ul>
</div></blockquote>
<p>Additional positional and keyword arguments in the <code class="docutils literal notranslate"><span class="pre">FunctionDict</span></code> are
passed to <code class="docutils literal notranslate"><span class="pre">function</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">function</span></code> argument must conform to the signature,</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">function</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">[</span><span class="n">float64</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">*</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">x</span></code> is a 1-D array containing a <code class="docutils literal notranslate"><span class="pre">len(Ns)</span></code> -dimensional grid
point.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>system_size</strong><span class="classifier">int</span></dt><dd><p>size of the simulated QVA</p>
</dd>
<dt><strong>local_i</strong><span class="classifier">int</span></dt><dd><p>size of the local <a class="reference internal" href="glossary.html#term-system-state"><span class="xref std std-term">system state</span></a> partition,
<a class="reference internal" href="#quop_mpi.Unitary" title="quop_mpi.Unitary"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Unitary</span></code></a> attribute</p>
</dd>
<dt><strong>local_i_offset</strong><span class="classifier">int</span></dt><dd><p>global index offset of the local system state partition,
<a class="reference internal" href="#quop_mpi.Unitary" title="quop_mpi.Unitary"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Unitary</span></code></a> attribute</p>
</dd>
<dt><strong>Ns</strong><span class="classifier">list[int]</span></dt><dd><p>the number of qubits assigned to each dimension of the cartesian grid
such that there is <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">**</span> <span class="pre">Ns[d]</span></code> grid points per dimension <code class="docutils literal notranslate"><span class="pre">d</span></code></p>
</dd>
<dt><strong>deltas</strong><span class="classifier">list[float]</span></dt><dd><p>step size in each Cartesian coordinate</p>
</dd>
<dt><strong>mins</strong><span class="classifier">list[float]</span></dt><dd><p>lower bound of each Cartesian coordinate</p>
</dd>
<dt><strong>function</strong><span class="classifier">Callable</span></dt><dd><p>a Python function that takes a list of <code class="docutils literal notranslate"><span class="pre">len(Ns)</span></code> real coordinate
values and returns a <code class="docutils literal notranslate"><span class="pre">float</span></code></p>
</dd>
<dt><strong>coeff</strong><span class="classifier">float</span></dt><dd><p>a positive real number, the upper bound of the scaling range</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray[float64]</dt><dd><p>a 1-D real array containing <code class="docutils literal notranslate"><span class="pre">local_i</span></code> elements of the operator
diagonal with global index offset <code class="docutils literal notranslate"><span class="pre">local_i_offset</span></code></p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#quop_mpi.propagator.diagonal.operator.setup_cartesian" title="quop_mpi.propagator.diagonal.operator.setup_cartesian"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setup_cartesian</span></code></a></dt><dd><p>compute <code class="docutils literal notranslate"><span class="pre">deltas</span></code> and <code class="docutils literal notranslate"><span class="pre">mins</span></code></p>
</dd>
<dt><a class="reference internal" href="#quop_mpi.propagator.diagonal.operator.cartesian_scaled" title="quop_mpi.propagator.diagonal.operator.cartesian_scaled"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cartesian_scaled</span></code></a></dt><dd><p>alternative to <code class="docutils literal notranslate"><span class="pre">cartesian_scaled</span></code>,  does not scale <code class="docutils literal notranslate"><span class="pre">function</span></code></p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quop_mpi.propagator.diagonal.operator.csv">
<span class="sig-prename descclassname"><span class="pre">quop_mpi.propagator.diagonal.operator.</span></span><span class="sig-name descname"><span class="pre">csv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">partition_table</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">MPI_COMM</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Intracomm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#quop_mpi.propagator.diagonal.operator.csv" title="Link to this definition"></a></dt>
<dd><p>Load the diagonal of a <a class="reference internal" href="glossary.html#term-Phase-Shift-Unitary"><span class="xref std std-term">phase-shift unitary</span></a> using 
<a class="reference external" href="https://pandas.pydata.org/">pandas</a>.</p>
<p>An <a class="reference internal" href="quop_functions.html#term-Operator-Function"><span class="xref std std-term">Operator Function</span></a> for the
<code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.propagate.diagonal.unitary</span></code> class. The <code class="docutils literal notranslate"><span class="pre">filename</span></code> argument must
be defined in a corresponding <a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> on initialisation of the
<code class="docutils literal notranslate"><span class="pre">unitary</span></code> instance. Additional keyword arguments in the <code class="docutils literal notranslate"><span class="pre">FunctionDict</span></code>
are passed to the 
<a class="reference external" href="https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html">pandas.read_csv</a>
method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>partition_table</strong><span class="classifier">list[int]</span></dt><dd><p>describes the parallel partitioning scheme, <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a>
attribute</p>
</dd>
<dt><strong>MPI_COMM</strong><span class="classifier">Intracomm</span></dt><dd><p>MPI communicator, <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a> attribute</p>
</dd>
<dt><strong>filename</strong><span class="classifier">Callable</span></dt><dd><p>path to a <code class="docutils literal notranslate"><span class="pre">*.csv</span></code> file</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray[float64]</dt><dd><p>a 1-D real array containing <code class="docutils literal notranslate"><span class="pre">local_i</span></code> elements of the operator
diagonal with global index offset <code class="docutils literal notranslate"><span class="pre">local_i_offset</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quop_mpi.propagator.diagonal.operator.hdf5">
<span class="sig-prename descclassname"><span class="pre">quop_mpi.propagator.diagonal.operator.</span></span><span class="sig-name descname"><span class="pre">hdf5</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">partition_table</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">MPI_COMM</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Intracomm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dataset_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#quop_mpi.propagator.diagonal.operator.hdf5" title="Link to this definition"></a></dt>
<dd><p>Load the diagonal of a <a class="reference internal" href="glossary.html#term-Phase-Shift-Unitary"><span class="xref std std-term">phase-shift unitary</span></a> using 
<a class="reference external" href="https://docs.h5py.org/en/latest/index.html">HDF5 for Python</a>.</p>
<p>An <a class="reference internal" href="quop_functions.html#term-Operator-Function"><span class="xref std std-term">Operator Function</span></a> for the
<code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.propagate.diagonal.unitary</span></code> class. The <code class="docutils literal notranslate"><span class="pre">filename</span></code> and
<code class="docutils literal notranslate"><span class="pre">dataset_name</span></code> arguments must be defined in a corresponding
<a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> on initialisation of the <code class="docutils literal notranslate"><span class="pre">unitary</span></code> instance.
Additional positional and keyword arguments in the <code class="docutils literal notranslate"><span class="pre">FunctionDict</span></code> are
passed to the <a class="reference external" href="https://docs.h5py.org/en/latest/high/file.html">h5py.File</a>
method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>partition_table</strong><span class="classifier">int</span></dt><dd><p>describes the parallel partitioning scheme, <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a>
attribute</p>
</dd>
<dt><strong>MPI_COMM</strong><span class="classifier">Intracomm</span></dt><dd><p>MPI communicator, <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a> attribute</p>
</dd>
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>path to a <code class="docutils literal notranslate"><span class="pre">*.h5</span> <span class="pre">file</span></code></p>
</dd>
<dt><strong>dataset_name</strong><span class="classifier">str</span></dt><dd><p>path to the dataset containing a <code class="docutils literal notranslate"><span class="pre">ndarray[float64]</span></code> of size
<a class="reference internal" href="glossary.html#term-system-size"><span class="xref std std-term">system size</span></a></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>np.ndarray[np.float64]</dt><dd><p>a 1-D real array containing <code class="docutils literal notranslate"><span class="pre">local_i</span></code> elements of the operator
diagonal with global index offset <code class="docutils literal notranslate"><span class="pre">local_i_offset</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quop_mpi.propagator.diagonal.operator.serial">
<span class="sig-prename descclassname"><span class="pre">quop_mpi.propagator.diagonal.operator.</span></span><span class="sig-name descname"><span class="pre">serial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">partition_table</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">MPI_COMM</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Intracomm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variational_parameters</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.float64</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.float64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#quop_mpi.propagator.diagonal.operator.serial" title="Link to this definition"></a></dt>
<dd><p>Generate the diagonal of the <a class="reference internal" href="glossary.html#term-operator"><span class="xref std std-term">operator</span></a> for one or more sequential
<a class="reference internal" href="glossary.html#term-Phase-Shift-Unitary"><span class="xref std std-term">phase-shift unitaries</span></a> using a serial Python
function.</p>
<p>An <a class="reference internal" href="quop_functions.html#term-Operator-Function"><span class="xref std std-term">Operator Function</span></a> for the
<a class="reference internal" href="#quop_mpi.propagator.diagonal.unitary" title="quop_mpi.propagator.diagonal.unitary"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.propagator.diagonal.unitary</span></code></a> class. The <code class="docutils literal notranslate"><span class="pre">function</span></code>
argument must be defined in a corresponding <a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> on
initialisation of the <code class="docutils literal notranslate"><span class="pre">unitary</span></code> instance. Additional positional and
keyword arguments contained in the FunctionDict are passed to <code class="docutils literal notranslate"><span class="pre">function</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">function</span></code> argument must conform to the signature,</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">*</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">ndarray</span><span class="p">[</span><span class="n">float64</span><span class="p">]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">ndarray</span><span class="p">[</span><span class="n">float64</span><span class="p">]])</span>
</pre></div>
</div>
</div></blockquote>
<p>where the output is a 1-D real array of type <code class="docutils literal notranslate"><span class="pre">ndarray[float64]</span></code> 
and length <a class="reference internal" href="glossary.html#term-system-size"><span class="xref std std-term">system size</span></a>, or <code class="docutils literal notranslate"><span class="pre">list</span></code> containing one or more 1-D 
real arrays of type <code class="docutils literal notranslate"><span class="pre">ndarray[float64]</span></code> and length <code class="docutils literal notranslate"><span class="pre">system_size</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>partition_table</strong><span class="classifier">list[int]</span></dt><dd><p>describes the parallel partitioning scheme, <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a> attribute</p>
</dd>
<dt><strong>MPI_COMM</strong><span class="classifier">Intracomm</span></dt><dd><p>MPI communicator, <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a> attribute</p>
</dd>
<dt><strong>variational_parameters</strong><span class="classifier">ndarray[float64]</span></dt><dd><p><a class="reference internal" href="glossary.html#term-operator-parameter"><span class="xref std std-term">operator parameters</span></a>, passed to <code class="docutils literal notranslate"><span class="pre">function</span></code> if
<code class="docutils literal notranslate"><span class="pre">unitary.operator_n_params</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>, <a class="reference internal" href="#quop_mpi.Unitary" title="quop_mpi.Unitary"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Unitary</span></code></a> attribute</p>
</dd>
<dt><strong>function</strong><span class="classifier">Callable</span></dt><dd><p>returns one or more <code class="docutils literal notranslate"><span class="pre">ndarray[float64]</span></code> of size <a class="reference internal" href="glossary.html#term-system-size"><span class="xref std std-term">system size</span></a>
corresponding to the diagonal of the operator of one or more phase-shift
unitaries</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray[float64] or list[ndarray[float64]]</dt><dd><p>a 1-d real array or list of 1-D real arrays containing a <code class="docutils literal notranslate"><span class="pre">local_i</span></code>
elements of the <a class="reference internal" href="glossary.html#term-operator"><span class="xref std std-term">operator</span></a> diagonal with global index offset
<code class="docutils literal notranslate"><span class="pre">local_i_offset</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quop_mpi.propagator.diagonal.operator.setup_cartesian">
<span class="sig-prename descclassname"><span class="pre">quop_mpi.propagator.diagonal.operator.</span></span><span class="sig-name descname"><span class="pre">setup_cartesian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Ns</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#quop_mpi.propagator.diagonal.operator.setup_cartesian" title="Link to this definition"></a></dt>
<dd><p>Compute the step-size and minimum coordinate values in each dimension of
a Cartesian grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Ns</strong><span class="classifier">list[int]</span></dt><dd><p>the number of qubits assigned to each dimension of the Cartesian grid
such that there is <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">**</span> <span class="pre">Ns[d]</span></code> grid points per dimension <code class="docutils literal notranslate"><span class="pre">d</span></code></p>
</dd>
<dt><strong>bounds</strong><span class="classifier">list[list[float]]</span></dt><dd><p>the lower and upper bounds of each dimension where 
<code class="docutils literal notranslate"><span class="pre">len(Ns)</span> <span class="pre">==</span> <span class="pre">len(bounds)</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>list[list[float]]</dt><dd><p>the step-size, <code class="docutils literal notranslate"><span class="pre">deltas</span></code>, and the minimum, <code class="docutils literal notranslate"><span class="pre">mins</span></code>, in each Cartesian
coordinate</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#quop_mpi.propagator.diagonal.operator.cartesian" title="quop_mpi.propagator.diagonal.operator.cartesian"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cartesian</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#quop_mpi.propagator.diagonal.operator.cartesian_scaled" title="quop_mpi.propagator.diagonal.operator.cartesian_scaled"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cartesian_scaled</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

</section>
</section>
<section id="module-quop_mpi.propagator.sparse">
<span id="sparse"></span><h3>sparse<a class="headerlink" href="#module-quop_mpi.propagator.sparse" title="Link to this heading"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="quop_mpi.propagator.sparse.unitary">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quop_mpi.propagator.sparse.</span></span><span class="sig-name descname"><span class="pre">unitary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.propagator.sparse.unitary" title="Link to this definition"></a></dt>
<dd><p>Compute the action of a <a class="reference internal" href="glossary.html#term-Mixing-Unitary"><span class="xref std std-term">mixing unitary</span></a> with a sparse
<a class="reference internal" href="glossary.html#term-operator"><span class="xref std std-term">operator</span></a> or a sequence of mixing-unitaries with sparse
operators (see the <code class="docutils literal notranslate"><span class="pre">unitary_n_params</span></code> attribute below).</p>
<p><strong>Inheritance Diagram:</strong></p>
<blockquote>
<div><div class="graphviz"><img src="_images/graphviz-7b00c6df2ff9e202effea730ff4e3b917991da58.png" alt="digraph &quot;sphinx-ext-graphviz&quot; {
    rankdir=&quot;LR&quot;;
    node [fontsize=&quot;10&quot;];
    Unitary[label=&quot;quop_mpi.Unitary&quot;, shape=&quot;rectangle&quot;];
    unitary[label=&quot;quop_mpi.propagator.sparse.unitary&quot;, shape=&quot;rectangle&quot;];

    Unitary -&gt; unitary;
}" class="graphviz" /></div>
</div></blockquote>
<p>See <a class="reference internal" href="#quop_mpi.Unitary" title="quop_mpi.Unitary"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Unitary</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>unitary_type</strong></dt><dd><p><code class="docutils literal notranslate"><span class="pre">'sparse'</span></code></p>
</dd>
<dt><strong>planner</strong></dt><dd><p><code class="docutils literal notranslate"><span class="pre">false</span></code></p>
</dd>
<dt><strong>unitary_n_params</strong></dt><dd><p>Set on initialisation to <code class="docutils literal notranslate"><span class="pre">1</span></code> or more. If <code class="docutils literal notranslate"><span class="pre">unitary_n_parameters</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>,
the <a class="reference internal" href="quop_functions.html#term-Operator-Function"><span class="xref std std-term">Operator Function</span></a> must return a <code class="docutils literal notranslate"><span class="pre">list[csr_matrix]</span></code> of
length <code class="docutils literal notranslate"><span class="pre">unitary_n_parameters</span></code> containing <code class="docutils literal notranslate"><span class="pre">csr_matrix</span></code> partitions of
of <code class="docutils literal notranslate"><span class="pre">local_i</span></code> rows.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.propagator.sparse.unitary.propagate">
<span class="sig-name descname"><span class="pre">propagate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.propagator.sparse.unitary.propagate" title="Link to this definition"></a></dt>
<dd><p>Simulation of the action of a :term`unitary`.</p>
<p>When implemented, <code class="docutils literal notranslate"><span class="pre">propagate</span></code> contains a call to a method (typically a
contained in a complied Python extension module) that takes the class
attributes <code class="docutils literal notranslate"><span class="pre">initial_state</span></code>, <code class="docutils literal notranslate"><span class="pre">final_state</span></code> and <code class="docutils literal notranslate"><span class="pre">MPI_COMM</span></code>, together
with attributes describing the parallel partitioning scheme and
<a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational parameters</span></a> <code class="docutils literal notranslate"><span class="pre">x</span></code>, as input. The action of the unitary
is computed in MPI parallel, with the computed result written to
<code class="docutils literal notranslate"><span class="pre">final_state</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Not implemented by the base <code class="docutils literal notranslate"><span class="pre">Unitary</span></code> class.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">ndarray[float64]</span></dt><dd><p>a 1-D real array of <code class="docutils literal notranslate"><span class="pre">n_params</span></code> <a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational parameters</span></a></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">propagate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>

    <span class="n">external_propagator</span><span class="p">(</span>
        <span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition_table</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_state</span><span class="p">,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final_state</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">MPI_COMM</span> <span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<section id="id38">
<h4>operators<a class="headerlink" href="#id38" title="Link to this heading"></a></h4>
<p id="module-quop_mpi.propagator.sparse.operator">Predefined <a class="reference internal" href="quop_functions.html#term-Operator-Function"><span class="xref std std-term">Operator Functions</span></a> for
<a class="reference internal" href="#quop_mpi.propagator.sparse.unitary" title="quop_mpi.propagator.sparse.unitary"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.propagator.sparse.unitary</span></code></a>.</p>
<p>Operator Functions for <code class="docutils literal notranslate"><span class="pre">unitary</span></code>  instances of type <code class="docutils literal notranslate"><span class="pre">'sparse'</span></code>  return CSR
partitions of one or more matrices. More than one CSR partition defines a
sequence of <a class="reference internal" href="glossary.html#term-Mixing-Unitary"><span class="xref std std-term">mixing unitaries</span></a> with independent
<a class="reference internal" href="glossary.html#term-unitary-parameter"><span class="xref std std-term">unitary parameters</span></a>.</p>
<p><strong>Partitioned CSR Matrix Format</strong></p>
<dl class="simple glossary">
<dt id="term-lb">lb<a class="headerlink" href="#term-lb" title="Link to this term"></a></dt><dd><p>lower index of the <a class="reference internal" href="glossary.html#term-system-state"><span class="xref std std-term">system state</span></a> and <a class="reference internal" href="glossary.html#term-observables"><span class="xref std std-term">observables</span></a> partition, <a class="reference internal" href="#quop_mpi.Unitary" title="quop_mpi.Unitary"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Unitary</span></code></a> attribute</p>
</dd>
<dt id="term-ub">ub<a class="headerlink" href="#term-ub" title="Link to this term"></a></dt><dd><p>upper index of the system state and observables partition, <a class="reference internal" href="#quop_mpi.Unitary" title="quop_mpi.Unitary"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Unitary</span></code></a> attribute</p>
</dd>
<dt id="term-W_col_index">W_col_index<a class="headerlink" href="#term-W_col_index" title="Link to this term"></a></dt><dd><p>a 1-D integer array containing non-zero column indexes for rows <code class="docutils literal notranslate"><span class="pre">lb</span></code> 
to <code class="docutils literal notranslate"><span class="pre">ub</span></code> , grouped by ascending row index</p>
</dd>
<dt id="term-W_values">W_values<a class="headerlink" href="#term-W_values" title="Link to this term"></a></dt><dd><p>a 1-D real array containing non-zero values for rows <code class="docutils literal notranslate"><span class="pre">lb</span></code>  to <code class="docutils literal notranslate"><span class="pre">ub</span></code> ,
grouped by ascending row index in the same order as <code class="docutils literal notranslate"><span class="pre">W_col_index</span></code></p>
</dd>
<dt id="term-W_row_start">W_row_start<a class="headerlink" href="#term-W_row_start" title="Link to this term"></a></dt><dd><p>an 1-D integer array of length <code class="docutils literal notranslate"><span class="pre">ub</span> <span class="pre">-</span> <span class="pre">lb</span> <span class="pre">+</span> <span class="pre">1</span></code> , a cumulative sum of the
number of non-zero elements in each row such that
<code class="docutils literal notranslate"><span class="pre">W_row_start[row_index</span> <span class="pre">+</span> <span class="pre">1]</span> <span class="pre">-</span> <span class="pre">W_row_start[row_index]</span></code>  is equal to the
number of non-zero elements in the row with index <code class="docutils literal notranslate"><span class="pre">row_index</span></code>  and
<code class="docutils literal notranslate"><span class="pre">W_rows_start[row]</span> <span class="pre">-</span> <span class="pre">local_i_offset</span></code>  gives the local starting index
for the non-zero column indexes and values in <code class="docutils literal notranslate"><span class="pre">W_col_index</span></code>  and
<code class="docutils literal notranslate"><span class="pre">W_values</span></code>  for the row with index <code class="docutils literal notranslate"><span class="pre">row_index</span></code></p>
</dd>
</dl>
<p>These are returned by the Operator Function as 
<code class="docutils literal notranslate"><span class="pre">list[list[W_row_start],</span> <span class="pre">list[W_col_indexes],</span> <span class="pre">list[W_values]]</span></code>.</p>
<dl class="py function">
<dt class="sig sig-object py" id="quop_mpi.propagator.sparse.operator.hypercube">
<span class="sig-prename descclassname"><span class="pre">quop_mpi.propagator.sparse.operator.</span></span><span class="sig-name descname"><span class="pre">hypercube</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lb</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ub</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.int64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.int64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.float64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#quop_mpi.propagator.sparse.operator.hypercube" title="Link to this definition"></a></dt>
<dd><p>Generate a hypercube (QAOA) sparse <a class="reference internal" href="glossary.html#term-Mixing-Unitary"><span class="xref std std-term">mixing unitary</span></a>
<a class="reference internal" href="glossary.html#term-operator"><span class="xref std std-term">operator</span></a>.</p>
<p>An <a class="reference internal" href="quop_functions.html#term-Operator-Function"><span class="xref std std-term">Operator Function</span></a> for
<a class="reference internal" href="#quop_mpi.propagator.sparse.unitary" title="quop_mpi.propagator.sparse.unitary"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.propagator.sparse.unitary</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>system_size</strong><span class="classifier">int</span></dt><dd><p>size of the simulated <a class="reference internal" href="glossary.html#term-QVA"><span class="xref std std-term">QVA</span></a>, <a class="reference internal" href="#quop_mpi.Unitary" title="quop_mpi.Unitary"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Unitary</span></code></a> attribute</p>
</dd>
<dt><strong>lb</strong><span class="classifier">int</span></dt><dd><p>lower index of the <a class="reference internal" href="glossary.html#term-system-state"><span class="xref std std-term">system state</span></a> partition,
<a class="reference internal" href="#quop_mpi.Unitary" title="quop_mpi.Unitary"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Unitary</span></code></a> attribute</p>
</dd>
<dt><strong>ub</strong><span class="classifier">int</span></dt><dd><p>upper index of the system state partition, <a class="reference internal" href="#quop_mpi.Unitary" title="quop_mpi.Unitary"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Unitary</span></code></a>
attribute</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>list[list[np.ndarray[np.int64]], list[np.ndarray[np.int64], list[np.ndarray[np.float64]]]]</dt><dd><p>a CSR partition of the hypercube (QAOA) mixing operator</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>RuntimeError</dt><dd><p>if <code class="docutils literal notranslate"><span class="pre">system_size</span> <span class="pre">%</span> <span class="pre">2</span> <span class="pre">!=</span> <span class="pre">0</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quop_mpi.propagator.sparse.operator.serial">
<span class="sig-prename descclassname"><span class="pre">quop_mpi.propagator.sparse.operator.</span></span><span class="sig-name descname"><span class="pre">serial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">partition_table</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">MPI_COMM</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Intracomm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variational_parameters</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.int64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.int64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.float64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#quop_mpi.propagator.sparse.operator.serial" title="Link to this definition"></a></dt>
<dd><p>Generate an <a class="reference internal" href="glossary.html#term-operator"><span class="xref std std-term">operator</span></a> for a sparse <a class="reference internal" href="glossary.html#term-Mixing-Unitary"><span class="xref std std-term">mixing unitary</span></a> using a
serial Python function.</p>
<p>An <a class="reference internal" href="quop_functions.html#term-Operator-Function"><span class="xref std std-term">Operator Function</span></a> for
<a class="reference internal" href="#quop_mpi.propagator.sparse.unitary" title="quop_mpi.propagator.sparse.unitary"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.propagator.sparse.unitary</span></code></a>. The <code class="docutils literal notranslate"><span class="pre">function</span></code> argument must
be defined via a corresponding <a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> on initialisation of the
<code class="docutils literal notranslate"><span class="pre">unitary</span></code> instance. Additional positional and keyword arguments in the
<code class="docutils literal notranslate"><span class="pre">FunctionDict</span></code> are passed the <code class="docutils literal notranslate"><span class="pre">function</span></code>. The signature for a
<code class="docutils literal notranslate"><span class="pre">function</span></code> generating an operator with one or more 
<a class="reference internal" href="glossary.html#term-operator-parameter"><span class="xref std std-term">operator parameters</span></a> is,</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">function</span><span class="p">(</span><span class="n">variational_parameters</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span>
<span class="nb">list</span><span class="p">[</span><span class="n">csr_matrix</span><span class="p">]</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">variational_parameters</span></code> may be excluded if
<code class="docutils literal notranslate"><span class="pre">unitary.operator_n_params</span> <span class="pre">=</span> <span class="pre">0</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>partition_table</strong><span class="classifier">list[int]</span></dt><dd><p>describes the parallel partitioning of the <a class="reference internal" href="glossary.html#term-observables"><span class="xref std std-term">observables</span></a> and
<a class="reference internal" href="glossary.html#term-system-state"><span class="xref std std-term">system state</span></a>, <a class="reference internal" href="#quop_mpi.Unitary" title="quop_mpi.Unitary"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Unitary</span></code></a> attribute</p>
</dd>
<dt><strong>MPI_COMM</strong><span class="classifier">Intracomm</span></dt><dd><p>MPI communicator, <a class="reference internal" href="#quop_mpi.Unitary" title="quop_mpi.Unitary"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Unitary</span></code></a> attribute</p>
</dd>
<dt><strong>variational_parameters</strong><span class="classifier">np.ndarray[np.float64]</span></dt><dd><p>a 1-D real array of operator parameters, passed to <code class="docutils literal notranslate"><span class="pre">function</span></code> if
<code class="docutils literal notranslate"><span class="pre">len(variational_parameters)</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>, <a class="reference internal" href="#quop_mpi.Unitary" title="quop_mpi.Unitary"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Unitary</span></code></a> attribute</p>
</dd>
<dt><strong>function</strong><span class="classifier">Callable</span></dt><dd><p>function returning a list of scipy CSR matrices</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>list[list[np.ndarray[np.int64]], list[np.ndarray[np.int64],</dt><dd></dd>
<dt>list[np.ndarray[np.float64]]]]</dt><dd><p>a CSR matrix partition</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError</dt><dd><p>if <code class="docutils literal notranslate"><span class="pre">function</span></code> does not return a <code class="docutils literal notranslate"><span class="pre">list</span></code> of scipy CSR matrices</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
</section>
<section id="module-quop_mpi.propagator.composite">
<span id="composite"></span><h3>composite<a class="headerlink" href="#module-quop_mpi.propagator.composite" title="Link to this heading"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="quop_mpi.propagator.composite.unitary">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quop_mpi.propagator.composite.</span></span><span class="sig-name descname"><span class="pre">unitary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Ns</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.propagator.composite.unitary" title="Link to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.propagator.composite.unitary.propagate">
<span class="sig-name descname"><span class="pre">propagate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.propagator.composite.unitary.propagate" title="Link to this definition"></a></dt>
<dd><p>Simulation of the action of a :term`unitary`.</p>
<p>When implemented, <code class="docutils literal notranslate"><span class="pre">propagate</span></code> contains a call to a method (typically a
contained in a complied Python extension module) that takes the class
attributes <code class="docutils literal notranslate"><span class="pre">initial_state</span></code>, <code class="docutils literal notranslate"><span class="pre">final_state</span></code> and <code class="docutils literal notranslate"><span class="pre">MPI_COMM</span></code>, together
with attributes describing the parallel partitioning scheme and
<a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational parameters</span></a> <code class="docutils literal notranslate"><span class="pre">x</span></code>, as input. The action of the unitary
is computed in MPI parallel, with the computed result written to
<code class="docutils literal notranslate"><span class="pre">final_state</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Not implemented by the base <code class="docutils literal notranslate"><span class="pre">Unitary</span></code> class.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">ndarray[float64]</span></dt><dd><p>a 1-D real array of <code class="docutils literal notranslate"><span class="pre">n_params</span></code> <a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational parameters</span></a></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">propagate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>

    <span class="n">external_propagator</span><span class="p">(</span>
        <span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition_table</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_state</span><span class="p">,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final_state</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">MPI_COMM</span> <span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<section id="id39">
<h4>operators<a class="headerlink" href="#id39" title="Link to this heading"></a></h4>
<span class="target" id="module-quop_mpi.propagator.composite.operator"></span><dl class="py function">
<dt class="sig sig-object py" id="quop_mpi.propagator.composite.operator.ith">
<span class="sig-prename descclassname"><span class="pre">quop_mpi.propagator.composite.operator.</span></span><span class="sig-name descname"><span class="pre">ith</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Ns</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#quop_mpi.propagator.composite.operator.ith" title="Link to this definition"></a></dt>
<dd><p>Generate the eigenvalues of a <a class="reference internal" href="theoretical_background.html#qmoa"><span class="std std-ref">QMOA</span></a> <a class="reference internal" href="glossary.html#term-Mixing-Unitary"><span class="xref std std-term">mixing unitary</span></a> 
<a class="reference internal" href="glossary.html#term-operator"><span class="xref std std-term">operator</span></a>.</p>
<p>An <a class="reference internal" href="quop_functions.html#term-Operator-Function"><span class="xref std std-term">Operator Function</span></a> for
<a class="reference internal" href="#quop_mpi.propagator.composite.unitary" title="quop_mpi.propagator.composite.unitary"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.propagator.composite.unitary</span></code></a>. The <code class="docutils literal notranslate"><span class="pre">Cs</span></code> keyword argument
may be defined via a corresponding <a class="reference internal" href="quop_functions.html#term-FunctionDict"><span class="xref std std-term">FunctionDict</span></a> on initialisation of
the receiving <code class="docutils literal notranslate"><span class="pre">unitary</span></code> instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Ns</strong><span class="classifier">list[int]</span></dt><dd><p>the number of grid points in each dimension of the Cartesian grid,
<a class="reference internal" href="#quop_mpi.propagator.composite.unitary" title="quop_mpi.propagator.composite.unitary"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.propagator.composite.unitary</span></code></a> attribute</p>
</dd>
<dt><strong>Cs</strong><span class="classifier">list[int], optional</span></dt><dd><p>specifies the i-th index of the circulant operators associated with
each dimension of the Cartesian grid, complete graphs by default</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray[complex128]</dt><dd><p>a 2-D complex array containing <code class="docutils literal notranslate"><span class="pre">local_i</span></code> eigenvalues of the QMOA
mixing unitary with global index offset <code class="docutils literal notranslate"><span class="pre">local_i_offset</span></code></p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-meth docutils literal notranslate"><span class="pre">quop_mpi.propagate.circulant.operator.graph()</span></code></dt><dd><p>Generate the eigenvalues of the i-th symmetric circulant graph with edge weights <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
</dd>
</dl>
</div>
</dd></dl>

</section>
</section>
<section id="module-quop_mpi.propagator.momentum">
<span id="momentum"></span><h3>momentum<a class="headerlink" href="#module-quop_mpi.propagator.momentum" title="Link to this heading"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="quop_mpi.propagator.momentum.unitary">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">quop_mpi.propagator.momentum.</span></span><span class="sig-name descname"><span class="pre">unitary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Ns</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minsq</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minsk</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deltasq</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deltask</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.propagator.momentum.unitary" title="Link to this definition"></a></dt>
<dd><p>Implements the <a class="reference internal" href="theoretical_background.html#qowe"><span class="std std-ref">QOWE</span></a> <a class="reference internal" href="glossary.html#term-Mixing-Unitary"><span class="xref std std-term">mixing unitary</span></a>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><code class="docutils literal notranslate"><span class="pre">unitary</span></code> instances of type <code class="docutils literal notranslate"><span class="pre">'momentum</span></code> require that the <code class="docutils literal notranslate"><span class="pre">size</span></code> of
the MPI communicator assocaited with <a class="reference internal" href="#quop_mpi.Ansatz" title="quop_mpi.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Ansatz</span></code></a> class be
a factor of the first grid dimension (<code class="docutils literal notranslate"><span class="pre">Ns[0]</span> <span class="pre">%</span> <span class="pre">size</span> <span class="pre">==</span> <span class="pre">0</span></code>).</p>
</div>
<p><strong>Inhertance Diagram:</strong></p>
<blockquote>
<div><div class="graphviz"><img src="_images/graphviz-4199047a2f9e9ff693e56fb78eeaeaf0e366f623.png" alt="digraph &quot;sphinx-ext-graphviz&quot; {
    rankdir=&quot;LR&quot;; node [fontsize=&quot;10&quot;];
    Unitary[label=&quot;quop_mpi.Unitary&quot;, shape=&quot;rectangle&quot;];
    unitary[label=&quot;quop_mpi.propagator.momentum.unitary&quot;,
    shape=&quot;rectangle&quot;];

    Unitary -&gt; unitary;
}" class="graphviz" /></div>
</div></blockquote>
<p>See <a class="reference internal" href="#quop_mpi.Unitary" title="quop_mpi.Unitary"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Unitary</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Ns</strong><span class="classifier">list[int]</span></dt><dd><p>the number of grid points in each dimension of the Cartesian grid in position and momentum space</p>
</dd>
<dt><strong>minsq</strong><span class="classifier">list[float]</span></dt><dd><p>the minimum of each Cartesian coordinate in position space</p>
</dd>
<dt><strong>minsk</strong><span class="classifier">list[float]</span></dt><dd><p>the minimum of each Cartesian coordinate in momentum space</p>
</dd>
<dt><strong>deltasq</strong><span class="classifier">list[float]</span></dt><dd><p>the step-size in each Cartesian coordinate in position space</p>
</dd>
<dt><strong>deltask</strong><span class="classifier">list[float]</span></dt><dd><p>the step-size in each Cartesian coordinate in momentum space</p>
</dd>
<dt><strong>*args and **kwargs:</strong></dt><dd><p>passed to the initialisation method of <a class="reference internal" href="#quop_mpi.Unitary" title="quop_mpi.Unitary"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.Unitary</span></code></a></p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>unitary_type</strong></dt><dd><p><code class="docutils literal notranslate"><span class="pre">'momentum'</span></code></p>
</dd>
<dt><strong>planner</strong></dt><dd><p><code class="docutils literal notranslate"><span class="pre">True</span></code></p>
</dd>
<dt><strong>unitary_n_params</strong></dt><dd><p><code class="docutils literal notranslate"><span class="pre">len(Ns)</span></code></p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="quop_mpi.propagator.momentum.unitary.propagate">
<span class="sig-name descname"><span class="pre">propagate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.propagator.momentum.unitary.propagate" title="Link to this definition"></a></dt>
<dd><p>Simulation of the action of a :term`unitary`.</p>
<p>When implemented, <code class="docutils literal notranslate"><span class="pre">propagate</span></code> contains a call to a method (typically a
contained in a complied Python extension module) that takes the class
attributes <code class="docutils literal notranslate"><span class="pre">initial_state</span></code>, <code class="docutils literal notranslate"><span class="pre">final_state</span></code> and <code class="docutils literal notranslate"><span class="pre">MPI_COMM</span></code>, together
with attributes describing the parallel partitioning scheme and
<a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational parameters</span></a> <code class="docutils literal notranslate"><span class="pre">x</span></code>, as input. The action of the unitary
is computed in MPI parallel, with the computed result written to
<code class="docutils literal notranslate"><span class="pre">final_state</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Not implemented by the base <code class="docutils literal notranslate"><span class="pre">Unitary</span></code> class.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">ndarray[float64]</span></dt><dd><p>a 1-D real array of <code class="docutils literal notranslate"><span class="pre">n_params</span></code> <a class="reference internal" href="glossary.html#term-variational-parameters"><span class="xref std std-term">variational parameters</span></a></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">propagate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>

    <span class="n">external_propagator</span><span class="p">(</span>
        <span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition_table</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_state</span><span class="p">,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final_state</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">MPI_COMM</span> <span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<section id="id40">
<h4>operators<a class="headerlink" href="#id40" title="Link to this heading"></a></h4>
<span class="target" id="module-quop_mpi.propagator.momentum.operator"></span><dl class="py function">
<dt class="sig sig-object py" id="quop_mpi.propagator.momentum.operator.magnitude_squared">
<span class="sig-prename descclassname"><span class="pre">quop_mpi.propagator.momentum.operator.</span></span><span class="sig-name descname"><span class="pre">magnitude_squared</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Ns</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minsk</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deltask</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.complex128</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#quop_mpi.propagator.momentum.operator.magnitude_squared" title="Link to this definition"></a></dt>
<dd><p>Generate the <a class="reference internal" href="theoretical_background.html#qmoa"><span class="std std-ref">QMOA</span></a> <a class="reference internal" href="glossary.html#term-Mixing-Unitary"><span class="xref std std-term">mixing unitary</span></a> <a class="reference internal" href="glossary.html#term-operator"><span class="xref std std-term">operator</span></a>.</p>
<p>An <a class="reference internal" href="quop_functions.html#term-Operator-Function"><span class="xref std std-term">Operator Function</span></a> for
<a class="reference internal" href="#quop_mpi.propagator.momentum.unitary" title="quop_mpi.propagator.momentum.unitary"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.propagator.momentum.unitary</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Ns</strong><span class="classifier">list[int]</span></dt><dd><p>the number of grid points in each dimension of the Cartesian grid in
position and momentum space,
<a class="reference internal" href="#quop_mpi.propagator.momentum.unitary" title="quop_mpi.propagator.momentum.unitary"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.propagator.momentum.unitary</span></code></a> attribute</p>
</dd>
<dt><strong>minsk</strong><span class="classifier">list[float]</span></dt><dd><p>the minimum of each Cartesian coordinate in momentum space,
<a class="reference internal" href="#quop_mpi.propagator.momentum.unitary" title="quop_mpi.propagator.momentum.unitary"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.propagator.momentum.unitary</span></code></a> attribute</p>
</dd>
<dt><strong>deltask</strong><span class="classifier">list[float]</span></dt><dd><p>the step-size in each Cartesian coordinate in momentum space,
<a class="reference internal" href="#quop_mpi.propagator.momentum.unitary" title="quop_mpi.propagator.momentum.unitary"><code class="xref py py-class docutils literal notranslate"><span class="pre">quop_mpi.propagator.momentum.unitary</span></code></a> attribute</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>np.ndarray[np.complex128]</dt><dd><p>a 1-D complex array of <code class="docutils literal notranslate"><span class="pre">local_i</span></code> elements of the QOWE diagonal
momentum-space operator with global index offset <code class="docutils literal notranslate"><span class="pre">local_i_offset</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
</section>
</section>
<section id="module-quop_mpi.toolkit">
<span id="toolkit"></span><h2>toolkit<a class="headerlink" href="#module-quop_mpi.toolkit" title="Link to this heading"></a></h2>
<p>Convieniance functions for use in user-defined <a class="reference internal" href="quop_functions.html#term-Initial-State-Function"><span class="xref std std-term">Initial State</span></a> and <a class="reference internal" href="quop_functions.html#term-Observables-Function"><span class="xref std std-term">Observables</span></a> functions.</p>
<dl class="py function">
<dt class="sig sig-object py" id="quop_mpi.toolkit.I">
<span class="sig-prename descclassname"><span class="pre">quop_mpi.toolkit.</span></span><span class="sig-name descname"><span class="pre">I</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">csr_matrix</span></span></span><a class="headerlink" href="#quop_mpi.toolkit.I" title="Link to this definition"></a></dt>
<dd><p>Generate a sparse identity matrix of size <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">**</span> <span class="pre">n_qubits</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n_qubits: int</strong></dt><dd><p>generate the identity operator for <code class="docutils literal notranslate"><span class="pre">n_qubits</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>csr_matrix</dt><dd><p>the identity operator for <code class="docutils literal notranslate"><span class="pre">n_qubits</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quop_mpi.toolkit.X">
<span class="sig-prename descclassname"><span class="pre">quop_mpi.toolkit.</span></span><span class="sig-name descname"><span class="pre">X</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">csr_matrix</span></span></span><a class="headerlink" href="#quop_mpi.toolkit.X" title="Link to this definition"></a></dt>
<dd><p>Generate the Pauli X operator acting on qubit <code class="docutils literal notranslate"><span class="pre">index</span></code> in a system of
<code class="docutils literal notranslate"><span class="pre">n_qubits</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">int</span></dt><dd><p>index of the qubit to which the X operator is applied</p>
</dd>
<dt><strong>n_qubits</strong><span class="classifier">int</span></dt><dd><p>total number of qubits in the system</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>csr_matrix</dt><dd><p>the Pauli X operator acting on qubit <code class="docutils literal notranslate"><span class="pre">index</span></code> in a system of <code class="docutils literal notranslate"><span class="pre">n_qubits</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quop_mpi.toolkit.Y">
<span class="sig-prename descclassname"><span class="pre">quop_mpi.toolkit.</span></span><span class="sig-name descname"><span class="pre">Y</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">csr_matrix</span></span></span><a class="headerlink" href="#quop_mpi.toolkit.Y" title="Link to this definition"></a></dt>
<dd><p>Generate the Pauli Y operator acting on qubit <code class="docutils literal notranslate"><span class="pre">index</span></code> in a system of
<code class="docutils literal notranslate"><span class="pre">n_qubits</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">int</span></dt><dd><p>index of the qubit to which the Y operator is applied</p>
</dd>
<dt><strong>n_qubits</strong><span class="classifier">int</span></dt><dd><p>total number of qubits in the system</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>csr_matrix</dt><dd><p>the Pauli Y operator acting on qubit <code class="docutils literal notranslate"><span class="pre">index</span></code> in a system of <code class="docutils literal notranslate"><span class="pre">n_qubits</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quop_mpi.toolkit.Z">
<span class="sig-prename descclassname"><span class="pre">quop_mpi.toolkit.</span></span><span class="sig-name descname"><span class="pre">Z</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quop_mpi.toolkit.Z" title="Link to this definition"></a></dt>
<dd><p>Generate the Pauli Z operator acting on qubit <code class="docutils literal notranslate"><span class="pre">index</span></code> in a system of
<code class="docutils literal notranslate"><span class="pre">n_qubits</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">int</span></dt><dd><p>index of the qubit to which the Z operator is applied</p>
</dd>
<dt><strong>n_qubits</strong><span class="classifier">int</span></dt><dd><p>total number of qubits in the system</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>csr_matrix</dt><dd><p>the Pauli Z operator acting on qubit <code class="docutils literal notranslate"><span class="pre">index</span></code> in a system of <code class="docutils literal notranslate"><span class="pre">n_qubits</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quop_mpi.toolkit.kron">
<span class="sig-prename descclassname"><span class="pre">quop_mpi.toolkit.</span></span><span class="sig-name descname"><span class="pre">kron</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">terms</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'sparse'</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">csr_matrix</span></span></span><a class="headerlink" href="#quop_mpi.toolkit.kron" title="Link to this definition"></a></dt>
<dd><p>Compute the tensor (Kronecker) product of a sequence of sparse matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>terms</strong><span class="classifier">list[sparse]</span></dt><dd><p>a list of scipy sparse matrices</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>csr_matrix</dt><dd><p>the tensor product of <code class="docutils literal notranslate"><span class="pre">terms</span></code>, computed from left to right</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quop_mpi.toolkit.kron_power">
<span class="sig-prename descclassname"><span class="pre">quop_mpi.toolkit.</span></span><span class="sig-name descname"><span class="pre">kron_power</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">term</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sparse</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">csr_matrix</span></span></span><a class="headerlink" href="#quop_mpi.toolkit.kron_power" title="Link to this definition"></a></dt>
<dd><p>Compute the tensor (Kronecker) product of <code class="docutils literal notranslate"><span class="pre">n</span></code> instances of a sparse matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>term</strong><span class="classifier">sparse</span></dt><dd><p>a scipy sparse matrix</p>
</dd>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>length of the tensor product sequence</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>csr_matrix</dt><dd><p>tensor product of <code class="docutils literal notranslate"><span class="pre">n</span></code> occurences of <code class="docutils literal notranslate"><span class="pre">term</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quop_mpi.toolkit.string">
<span class="sig-prename descclassname"><span class="pre">quop_mpi.toolkit.</span></span><span class="sig-name descname"><span class="pre">string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">np.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.complex128</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#quop_mpi.toolkit.string" title="Link to this definition"></a></dt>
<dd><p>Generate an <a class="reference internal" href="glossary.html#term-initial-state"><span class="xref std std-term">initial state</span></a> from a bit-string representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>state</strong><span class="classifier">str</span></dt><dd><p>a bit string state.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray[complex128]</dt><dd><p>the parsed quantum state</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="examples.html" class="btn btn-neutral float-left" title="Examples" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="quop_functions.html" class="btn btn-neutral float-right" title="QuOp Functions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Edric Matwiejew.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>